<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Base64加密解密]]></title>
    <url>%2F2019%2F07%2F06%2FBase64%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[参考Java8 Base64BASE64在线加密解密 Android自带Base64加密1234import android.util.Base64;String encode2 = new String(Base64.encode("123456".getBytes(), Base64.DEFAULT)); // 结果为"MTIzNDU2\n"// encodeToString内部其实也是调用encode方法，若想直接返回String，推荐用该方法String encode1 = Base64.encodeToString("123456".getBytes(), Base64.DEFAULT); // 结果为"MTIzNDU2\n" 这里要注意以上方法最终返回的结果都有换行符\n，如果不要换行可以用trim()做以下处理 123import android.util.Base64;String encode2 = new String(Base64.encode("123456".getBytes(), Base64.DEFAULT)).trim(); // 结果为"MTIzNDU2"String encode1 = Base64.encodeToString("123456".getBytes(), Base64.DEFAULT).trim(); // 结果为"MTIzNDU2" Android自带Base64解密1234import android.util.Base64;String decode1 = new String(Base64.decode("MTIzNDU2".getBytes(), Base64.DEFAULT)); // 结果为"123456"// 该方式内部其实也是调用上面那个方法，省去了getBytes()，推荐用此方法String decode2 = new String(Base64.decode("MTIzNDU2", Base64.DEFAULT)); // 结果为"123456" Java自带Base64加密解密参考Java8 Base64以上例子用的是Android自带的android.util.Base64类 其实Java也有个java.util.Base64，但是这个类需在Android API 26及以上才可以使用 12345String encode1 = new String(Base64.getEncoder().encode("123456".getBytes())); // 结果为"MTIzNDU2"String encode2 = Base64.getEncoder().encodeToString("123456".getBytes()); // 结果为"MTIzNDU2"String decode1 = new String(Base64.getDecoder().decode("MTIzNDU2".getBytes())); // 结果为"123456"String decode2 = new String(Base64.getDecoder().decode("MTIzNDU2")); // 结果为"123456" 可以看到编码的结果不像Android自带的末尾还有换行符\n 关于Java的Base64还有以下方法 Base64.getUrlEncoder(); Base64.getMimeEncoder(); Base64.getUrlDecoder(); Base64.getMimeDecoder(); 这里不再展开，以后另开一篇文章介绍如果你喜欢我的文章，可以关注我的微信公众号，可以看到我最新发布的文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 虚拟环境 virtualenv]]></title>
    <url>%2F2019%2F07%2F06%2FPython-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-virtualenv%2F</url>
    <content type="text"><![CDATA[virtualenv安装1pip install virtualenv 创建虚拟环境123C:\Users\Him&gt;d: // 切换到D:盘D:\&gt;cd D:\Python\env // 进入到要创建虚拟环境的目录下D:\Python\env&gt;virtualenv myenv // 创建成功后在D:\Python\env目录下会多一个myenv目录 也可以在创建时指定python版本 1virtualenv -p D:\Program\Python27\python.exe myenv27 进入虚拟环境123D:\Python\env&gt;cd myenv\Scripts // 进入虚拟环境的Scripts目录下D:\Python\env\myenv\Scripts&gt;activate // 运行activate(myenv) D:\Python\env\myenv\Scripts&gt; // 激活成功，注意命令行前多了(myenv) 查看虚拟环境下安装的库123456(myenv) D:\Python\env\myenv\Scripts&gt;pip listPackage Version---------- -------pip 18.0setuptools 40.0.0wheel 0.31.1 在虚拟环境下安装库1(myenv) d:\Python\env\myenv\Scripts&gt;pip install request 退出虚拟环境12(myenv) D:\Python\env\myenv\Scripts&gt;deactivateD:\Python\env\myenv\Scripts&gt; // 注意命令行前的(myenv)没了 requirements文件将当前环境的包写入requirements文件文件，以及根据requirements文件文件安装包。 生成requirements文件文件：pip freeze &gt;requirements.txt 根据requirements文件安装包：pip install -r requirements.txt requirements.txt文件的格式如下： 12345678910111213141516Flask==0.11.1Flask-Bootstrap==3.3.6.0Flask-Login==0.3.2Flask-Migrate==1.8.1Flask-Moment==0.5.1Flask-PageDown==0.2.1Flask-Script==2.0.5Flask-SQLAlchemy==2.1Flask-WTF==0.12html5lib==0.9999999itsdangerous==0.24Jinja2==2.8Mako==1.0.4Markdown==2.6.6MarkupSafe==0.23PyMySQL==0.7.5]]></content>
  </entry>
  <entry>
    <title><![CDATA[python itertools]]></title>
    <url>%2F2019%2F07%2F06%2Fpython-itertools%2F</url>
    <content type="text"><![CDATA[islice切片 123456789101112131415161718192021222324252627&gt;&gt;&gt; def count(n):... while True:... yield n... n += 1...&gt;&gt;&gt; c = count(0)&gt;&gt;&gt; c[10:20]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;generator&apos; object is not subscriptable&gt;&gt;&gt; # Now using islice()&gt;&gt;&gt; import itertools&gt;&gt;&gt; for x in itertools.islice(c, 10, 20):... print(x)...10111213141516171819&gt;&gt;&gt; 123456789101112131415In [97]: ls = [0,1,2,3,4,5,6,7,8,9]In [98]: for i in itertools.islice(ls, None, 3): # 等价于ls[:3] ...: print(i)012In [99]: for i in itertools.islice(ls, 4, None): # 类似于ls[4:] ...: print(i)456789 dropwhile抛弃符合函数的值，但是实际测试跟我所理解的有所出入 如下代码本来期望去掉b开头的，结果却全部输出了 12345678In [105]: for i in itertools.dropwhile(lambda item : item.startswith(&apos;b&apos;), ls): ...: print(i)a1b1a2b2a3b3 再试，去掉小于4的怪哉了，换成数字却又可以了 1234567In [106]: ls = [1,2,3,4,5,6,7,8]In [107]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)5678 再试，条件一样还是去掉大于5的，改变列表值这次又不是我所期望的但是好像有点眉目了，第一个item不满足条件就直接输出全部了我们是不是可以假设该函数抛弃前面满足条件的值，直到出现不满足的值后就不再判断，即使在这个值后可能还会出现满足条件的值也不再抛弃 1234567891011In [108]: ls = [6,3,8,9,1,5,4,2]In [109]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)63891542 二话不说，赶紧验证一下 1234567891011In [110]: ls = [1,2,3,4,6,3,8,9,1,5,4,2]In [111]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)63891542 果然如此 permutations排列（与顺序有关） 123456789101112131415161718In [112]: items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]In [113]: for i in itertools.permutations(items): # 默认排列的长度为items的长度 ...: print(i)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;c&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;c&apos;, &apos;a&apos;)(&apos;c&apos;, &apos;a&apos;, &apos;b&apos;)(&apos;c&apos;, &apos;b&apos;, &apos;a&apos;)In [114]: for i in itertools.permutations(items, 2): # 指定排列的长度 ...: print(i)(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;a&apos;)(&apos;b&apos;, &apos;c&apos;)(&apos;c&apos;, &apos;a&apos;)(&apos;c&apos;, &apos;b&apos;) combinations组合（与顺序无关） 1234567891011121314151617In [112]: items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]In [116]: for i in itertools.combinations(items, 3): ...: print(i)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)In [117]: for i in itertools.combinations(items, 2): ...: print(i)(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;c&apos;)In [118]: for i in itertools.combinations(items, 1): ...: print(i)(&apos;a&apos;,)(&apos;b&apos;,)(&apos;c&apos;,) combinations_with_replacement元素可重复出现的组合 123456In [119]: items = [&apos;a&apos;, &apos;b&apos;]In [120]: for i in itertools.combinations_with_replacement(items, 2): ...: print(i)(&apos;a&apos;, &apos;a&apos;)(&apos;a&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;b&apos;) zip_longest功能与内置函数zip类似，只是输出以最长的序列为准 12345678910111213141516171819202122In [45]: import itertoolsIn [26]: als = [1,2,3,4,5,6]In [27]: bls = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]In [46]: for a,b in itertools.zip_longest(als,bls): # 输出以最长的序列为准，不足的为None ...: print(a,b)1 a2 b3 c4 d5 None6 None# None替换成fillvalue的值In [48]: for a,b in itertools.zip_longest(als,bls,fillvalue=&apos;letter&apos;): ...: print(a,b)1 a2 b3 c4 d5 letter6 letter chain123456789101112131415161718In [49]: import itertoolsIn [50]: als = [1,2,3,4]In [51]: bls = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)# 注意两种不同类型的可迭代随想也可以完美输出In [52]: for item in itertools.chain(als,bls): ...: print(item)1234abcd# 类型In [53]: type(itertools.chain(als,bls))Out[53]: itertools.chain]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android js和原生交互]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-js%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[简单的demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.xindeco.swingu_h5;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.webkit.JavascriptInterface;import android.webkit.ValueCallback;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.EditText;import android.widget.Toast;import com.xindeco.reader.common.Action;import com.xindeco.reader.common.ReaderListener;import com.xindeco.reader.common.Tag;import com.xindeco.reader.swingu.SwingUReader;public class MainActivity extends AppCompatActivity &#123; private WebView mWebView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); &#125; private void init() &#123; mWebView = findViewById(R.id.web_view); mWebView.loadUrl(&quot;file:///android_asset/test.html&quot;); WebSettings webSettings = mWebView.getSettings(); webSettings.setJavaScriptEnabled(true); mWebView.addJavascriptInterface(new JsInteration(), &quot;android&quot;); mWebView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (url.equals(&quot;https://www.baidu.com/&quot;)) &#123; Toast.makeText(MainActivity.this, &quot;就是要拦你&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; else &#123; mWebView.loadUrl(url); return true; &#125; &#125; &#125;); findViewById(R.id.call_js).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; final EditText input = findViewById(R.id.input); String content = input.getText().toString().trim(); if (!TextUtils.isEmpty(content)) &#123; // 调用js方法，更新页面// mWebView.loadUrl(&quot;javascript:change(\&quot;&quot; + content + &quot;\&quot;)&quot;); // 没带返回值的调用方式 mWebView.evaluateJavascript(&quot;javascript:change(\&quot;&quot; + content + &quot;\&quot;)&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; input.setText(value); &#125; &#125;); &#125; &#125; &#125;); &#125; public class JsInteration &#123; @JavascriptInterface public String toast(String msg) &#123; Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show(); return &quot;我是java的返回值&quot;; &#125; &#125;&#125; 布局 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/input&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;我要改变网页的内容&quot;/&gt; &lt;Button android:id=&quot;@+id/call_js&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我是原生的button啦&quot;/&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; HTML页面，把该页面放置在assets文件夹下 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;content-type&quot;&gt; &lt;title&gt;js和原生交互&lt;/title&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;!--该方法调用原生的toast方法--&gt; function toast()&#123; var s = document.getElementById(&quot;input_toast&quot;).value; var result = window.android.toast(s); document.getElementById(&quot;input_toast&quot;).value=result; &#125; &lt;!--该方法被原生调用--&gt; function change(content)&#123; document.getElementById(&quot;input_toast&quot;).value=content; return &quot;我是js的返回值&quot;; &#125; &lt;/script&gt; &lt;body&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;input_toast&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;toast&quot; value=&quot;toast&quot; onclick=&quot;toast()&quot;/&gt; &lt;/p&gt; &lt;a href=&quot;https://www.taobao.com/&quot;&gt;跳转淘宝，不拦你&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;https://www.baidu.com/&quot;&gt;跳转百度，别拦我&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 记得添加&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;权限才能访问网络]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android自定义标题栏]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[void onCreate(Bundle savedInstanceState) &#123;123456public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_CUSTOM_TITLE); // 必须设置在setContentView之前。 setContentView(R.layout.activity_main); getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.custom_title);//custom_title为自定义标题栏布局&#125; 修改AndroidManifest.xml中该Activity的theme为以下： 其中parent要设为android:Theme或android:Theme.Light，不能设为android:Theme.Holo.Light，否则会报You cannot combine custom titles with other title features错误，可能是因为android:Theme.Holo.Light是用于ActionBar的，跟自定义标题栏有冲突。 50dp//改为跟自定义标题栏的高度一样 @color/title_bg//改为跟自定义标题栏的背景一样]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 的文件存储]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[选择内存储还是外存储 所有安卓设备都有两个存储区域，内存储和外存储。以前的安卓设备都有提供一个内置的存储（内存储），和一个可插拔的存储（外存储），例如SD卡。但是现在的许多设备是不支持外置存储卡的，而是把内置的存储分成两个区域，相当于内存储和存储。所以不管设备是否支持外置存储卡，它都有内存储和外存储这两个区域。存储操作相关API的调用是一样的。以下是内存储和外存储的区别： 内存储： 一直可用 默认情况下，存储于此的文件只有该应用本身有权限操作。 当用户卸载该应用，系统会删除该应用存储在内存储的所有文件。 如果你不想用户和其他应用操作你的文件，最好的方式就是保存在内存储。 外存储： 并非一直可用，比如当用户用数据线连接电脑并打开数据存储或者移除存储卡。 对用户和其他应用可读。 当用户卸载该应用时必不会删除存储在外存储的文件，除非你保存的时候调用的是getExternalFilesDir(). 如果你要保存的文件对操作权限没有要求，比如和其他应用共享或者允许用户操作，那么最好的方式就是存储在外存储。 Tip:** 默认情况下应用是安装在内存储，但是你可以在manifest中指定android:installLocation的属性值让应用安装在外存储上。特别是当应用应用特别大，而用户又有足够的问存储空间时。更多详情，请查阅App Install Location。 获得外存储权限 要在外存储上执行写的操作，必须在manifest文件中请求WRITE_EXTERNAL_STORAGE权限： 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; Caution:目前，所有应用不必声明相关权限就可以在外存储上执行读的操作。然而，不久的将来就需要了。如果你的应用需要读取的操作（不需要写的操作），你可以在manifest中声明READ_EXTERNAL_STORAGE权限，这样可以保证应用在后续版本中正常运行（即使当前系统并不要求该权限）。 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; 如果你的应用已经声明了WRITE_EXTERNAL_STORAGE权限，就没必要再声明READ_EXTERNAL_STORAGE权限，因为WRITE_EXTERNAL_STORAGE默认包含了写的权限。 You don’t need any permissions to save files on the internal storage. Your application always has permission to read and write files in its internal storage directory.对于内存储并不需要任何读写的权限。 在内存储中保存文件 当要在内存储存储文件时，可以通过以下两种方式获取合适的存储位置： getFilesDir() 返回一个分配给该应用的内存储文件夹。 getCacheDir() 返回一个分配给该应用的内存储缓存文件夹File对象。当缓存文件不再需要时记得删除掉。当系统存储不够用时，系统可能会删除掉缓存的文件且没有提示。 要在以上任一种文件夹中创建文件时，可以用File(dir, fileName)构造方法，第一个参数传入以上其中一种方法返回的内存储文件夹对象： 1File file = new File(context.getFilesDir(), filename); 还有另一种方法，你可以调用[openFileOutput()](http://developer.android.com/reference/android/content/Context.html#openFileOutput(java.lang.String, int))来打开一个连接内存储文件的FileOutputStream 对象。如下所示如何在内存储文件中写入内容： 1234567891011String filename = &quot;myfile&quot;;String string = &quot;Hello world!&quot;;FileOutputStream outputStream;try &#123; outputStream = openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(string.getBytes()); outputStream.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 或者说，你需要缓存文件，你可以使用[createTempFile()](http://developer.android.com/reference/java/io/File.html#createTempFile(java.lang.String, java.lang.String))。例如以下的示例从一个URL中提取出文件名，再用这个文件名创建一个存储在缓存文件夹中的文件： 12345678910public File getTempFile(Context context, String url) &#123; File file; try &#123; String fileName = Uri.parse(url).getLastPathSegment(); file = File.createTempFile(fileName, null, context.getCacheDir()); catch (IOException e) &#123; // Error while creating file &#125; return file;&#125; Note:一个应用的内存储空间是由应用包名标示的在安卓文件系统中的一个特定区域，技术上来讲，如果把文件的mode设为可读，那么其他应用就可访问。但是，前提是其他应用必须预先知道你的应用的包名和要访问的文件名。除非你明确声明某个文件为可读或可写，否则其他应用无法访问你的内存储文件也没有读写的权限。 在外存储中保存文件 因为外存储有可能是不可用的，比如当用户打开USB数据存储或者是卸载提供外存储的SD卡时，所以每当你要使用外存储是最好先核实下外存储是否可用。你可以通过调用getExternalStorageState()来查询外存储的状态。如果返回的状态是MEDIA_MOUNTED，那么表示你可以读写外存储。例如，以下两个非常实用的方法可以用来确定外存储的可用性： 123456789101112131415161718/* Checks if external storage is available for read and write确定问存储是否可读写 */public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;/* Checks if external storage is available to at least read 确定外存储是都至少可读*/public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; 虽然说整个外存储对于用户和所有应用都是可操作的，但是有两种类型的文件你可能会存储在这里： 公开文件 对其他应用和用户开放的文件应该存储在这里，当用户卸载你的应用时，这些文件应该保留。比如你的应用拍摄的图片或下载的文件。 私有文件 完全属于你的应用的文件并且在用户卸载你的应用时应该被删除的文件可以存储在这里。虽然技术上来说，存储在外存储的文件对于用户和其他应用都可以访问，但是这些文件对于用户和其他应用一文不值。当用户删除你的应用时，系统会自动删除你的应用存储在这里的所有文件。比如说你的应用下载的资源文件或临时的文件。 如果你想在外存储中保存公共文件，可以用getExternalStoragePublicDirectory()方法来获取一个在外存储中的File文件夹对象。这个方法的第一个参数用来指定要保存的文件的类型，可以被系统分类，例如DIRECTORY_MUSIC或者DIRECTORY_PICTURES。如下所示： 123456789public File getAlbumStorageDir(String albumName) &#123; // Get the directory for the user&apos;s public pictures directory. File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 如果你想保存应用私有的文件，可以调用getExternalFilesDir()来获取相应的文件夹，并在第一个参数指定你想要的类型。每个用这个方式创建的文件夹都是放在一个父文件夹里，这个父文件夹存里放着所有当用户卸载该应用时系统会自动删除的文件。 例如，以下的方法用来创建一个存放照片的文件夹： 123456789public File getAlbumStorageDir(Context context, String albumName) &#123; // Get the directory for the app&apos;s private pictures directory. File file = new File(context.getExternalFilesDir( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 如果没有一个系统预定义的类型子文件夹的名字适合你要保存的文件，你也可以在调用getExternalFilesDir()方法时第一个参数传null，这样返回的是在外存储中分配给你的应用的私有文件夹根目录。 要记住，存储在由getExternalFilesDir()返回的文件夹中的文件，当用户卸载你的应用时，这些文件全部会被删除。如果你想要用户删除你的应用后还保留这些文件，最好是使用getExternalStoragePublicDirectory()方法。比如说你的应用是个相机应用，当卸载该应用时用户还想保留所拍的照片。 不管你是用getExternalStoragePublicDirectory()来存储共享的文件，还是用getExternalFilesDir()来存储私有文件，最好是使用API常量定义的文件夹名，比如DIRECTORY_PICTURES。使用这些文件夹名可以确保系统正确分类这些文件。例如，保存在DIRECTORY_RINGTONES中的文件会被系统media scanner归类为铃音而非音乐。 查询剩余存储空间 如果你在保存某一文件时事先知道该文件的大小，你可以通过调用getFreeSpace() 或者 getTotalSpace()来确定是否有足够的存储空间来保存该文件以免造成IOException异常。 但是，系统并不保证你通过getFreeSpace()查询出来有多少剩余存储就可以存储多少。如果剩余存储容量比你要存储的文件大小大个几MB，那么一般可以成功存储。 Note:其实你也可以不用在存储文件前预先查询剩余多少存储空间，你可以尝试着直接写入数据，然后如果有出现异常直接捕获就行了。这种写法一般可以用在当你事先不知道要写入数据的大小的时候。比如说当你要保存一张PNG格式的图片前要先把他转化为JPEG格式，那么你就不知道要保存的数据的大小。 删除文件 你应该经常删除不再需要的文件，最直接的方法就是直接调用File对象的delete()方法。 1myFile.delete(); 如果要删除的文件是存储在内存储中，你可以通过调用Conext的deleteFile()方法来删除。 1myContext.deleteFile(fileName); Note:当用户卸载你的应用时，安卓系统会自动删除以下位置的文件： 存储在内存储中的所有文件 通过getExternalFilesDir()方法存储在外存储中的所有文件。 然而你应该制定一个规则定期删除内存储缓存文件夹中的缓存文件和其他你不再需要的文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Failed to fetch URL https://dl-ssl.google.com/android/repository/addons_list-1.xml]]></title>
    <url>%2F2019%2F07%2F06%2FFailed-to-fetch-URL-https-dl-ssl-google-com-android-repository-addons-list-1-xml%2F</url>
    <content type="text"><![CDATA[Do the following: Close the sdk manager and eclipse. Go to the folder where you have stored your adt. In that adt folder you’ll find a folder known as tools. Make a copy of the contents of that folder and paste it in a folder called copytools. Now go to the command prompt and go to the location of the copytools. Then execute the command android.bat the sdk manager will start. Now update all the plugins you want. It’ll update your original folder. After the update delete the copy.]]></content>
  </entry>
  <entry>
    <title><![CDATA[java进制转换]]></title>
    <url>%2F2019%2F07%2F06%2Fjava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728int n1 = 14;//十进制转成十六进制：Integer.toHexString(n1);//十进制转成八进制Integer.toOctalString(n1);//十进制转成二进制Integer.toBinaryString(12);//十六进制转成十进制Integer.valueOf("FFFF",16).toString();//十六进制转成二进制Integer.toBinaryString(Integer.valueOf("FFFF",16));//十六进制转成八进制Integer.toOctalString(Integer.valueOf("FFFF",16));//八进制转成十进制Integer.valueOf("576",8).toString();//八进制转成二进制Integer.toBinaryString(Integer.valueOf("23",8));//八进制转成十六进制Integer.toHexString(Integer.valueOf("23",8));//二进制转十进制Integer.valueOf("0101",2).toString();//二进制转八进制Integer.toOctalString(Integer.parseInt("0101", 2));//二进制转十六进制Integer.toHexString(Integer.parseInt("0101", 2));]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView.ItemDecoration实现StrickyHeader、粘性头部、悬停头部]]></title>
    <url>%2F2019%2F06%2F19%2FRecyclerView-ItemDecoration%E5%AE%9E%E7%8E%B0StrickyHeader%E3%80%81%E7%B2%98%E6%80%A7%E5%A4%B4%E9%83%A8%E3%80%81%E6%82%AC%E5%81%9C%E5%A4%B4%E9%83%A8%2F</url>
    <content type="text"><![CDATA[参考 RecyclerView探索之通过ItemDecoration实现StickyHeader效果这篇文章真是完美，写得非常清晰，一步步实现下来，看完真是茅塞顿开，以前一直以为这个知识点很难的。 Android 从零开始实现RecyclerView分组及粘性头部效果这篇文章貌似更牛逼，但是没深入去看 RecyclerView 悬浮/粘性头部——StickyHeaderDecoration 其实在GitHub上已经有很多开源的很成熟的StickyHeader项目 timehop/sticky-headers-recyclerview 先来实现效果镇楼 实现代码Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.him.stickyheader;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public List&lt;String&gt; datas; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView mRecyclerView = findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.addItemDecoration(new MyItemDecoration(new MyItemDecoration.GroupInfoCallback() &#123; // 根据全局数据的位置position查询所属分组的信息GroupInfo @Override public GroupInfo getGroupInfo(int position) &#123; // 测试数据，暂时10条数据一组 int size = 10; GroupInfo info = new GroupInfo(); info.groupId = position / size; info.title = info.groupId + &quot;&quot;; info.position = position % size; info.groupSize = size; return info; &#125; &#125;)); initDatas(); mRecyclerView.setAdapter(new MyAdapter(datas)); &#125; // 初始化测试数据 private void initDatas() &#123; datas = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100;i++) &#123; datas.add(&quot;test &quot; + i); &#125; &#125;&#125; Adapter 1234567891011121314151617181920212223242526272829303132333435363738394041package com.him.stickyheader;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; public List&lt;String&gt; datas; public MyAdapter(List&lt;String&gt; datas) &#123; this.datas = datas; &#125; @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View itemView = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item, viewGroup, false); return new MyViewHolder(itemView); &#125; @Override public void onBindViewHolder(@NonNull MyViewHolder viewHolder, int i) &#123; viewHolder.text.setText(datas.get(i)); &#125; @Override public int getItemCount() &#123; return datas == null ? 0 :datas.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView text; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); text = itemView.findViewById(R.id.text); &#125; &#125;&#125; ItemDecoration，这是最重要的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.him.stickyheader;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.View;import java.util.function.IntBinaryOperator;public class MyItemDecoration extends RecyclerView.ItemDecoration &#123; // 普通分割线的高度 private int dividerHeight = 1; // 分组header高度 private int headerHeight = 65; // 根据position获取分组信息的回调 private GroupInfoCallback callback; // 画笔 private Paint paint; public MyItemDecoration(GroupInfoCallback callback) &#123; this.callback = callback; paint = new Paint(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int itemPosition = parent.getChildAdapterPosition(view); GroupInfo info = callback.getGroupInfo(itemPosition); if (info.isFirstItem()) &#123; // 分组第一个item撑开一个header的高度 outRect.top = headerHeight; &#125; else &#123; // 其他item撑开一个普通divider的高度 outRect.top = dividerHeight; &#125; &#125; @Override public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123; super.onDraw(c, parent, state); // header左右边的坐标，注意考虑parent的左右padding float left = parent.getPaddingLeft(); float right = parent.getWidth() - parent.getPaddingRight(); // 循环RecyclerView中当前可见的View for (int i = 0; i &lt; parent.getChildCount(); i++) &#123; View child = parent.getChildAt(i); // 根据当前view获取在整个列表中的位置 int itemPosition = parent.getChildAdapterPosition(child); // 根据position获取所属分组的信息 GroupInfo info = callback.getGroupInfo(itemPosition); // 重点来了，敲黑板 // 注意这里的i表示在RecyclerView当前可见View中的位置（第几个） // i == 0表示当前可见的第一个View // 这里绘制分组标题悬停的效果 if (i == 0) &#123; // 分组标题停在最顶部，就是parent的顶部，然后再考虑顶部的padding float top = parent.getPaddingTop(); // top加分组高度就是底部坐标 float bottom = top + headerHeight; // 这里是第二个重点 // 如果没这段代码，就无法实现下面的分组标题把当前悬停的分组标题往上推出页面的效果 // 分组的最后一个item且该item的底部坐标小于悬停顶部的header的底部坐标的情况下，需执行以下代码，重新计算header的位置 if (info.isLastItem() &amp;&amp; bottom &gt; child.getBottom()) &#123; bottom = child.getBottom(); top = bottom - headerHeight; &#125; drawHeader(left, top, right, bottom, c, info); &#125; else if (info.isFirstItem()) &#123; // 如果不是可见的第一个view但是是分组的第一个item，则绘制分组标题 // item的顶部再往上一个header的高度 float top = child.getTop() - headerHeight; // 顶部坐标加上header高度就是底部坐标 float bottom = top + headerHeight; drawHeader(left, top, right, bottom, c, info); &#125; &#125; &#125; // 根据计算出的header位置绘制header及header中的title private void drawHeader(float left, float top, float right, float bottom, Canvas c, GroupInfo info) &#123; // 设置header背景色，然后绘制 paint.setColor(Color.GREEN); c.drawRect(left, top, right, bottom, paint); // 设置title文字大小，然后计算文字高度，用于接下来计算文字绘制的位置 paint.setTextSize(32); paint.setColor(Color.BLUE); Rect rect = new Rect(); // 计算要绘制的文字的宽高 paint.getTextBounds(info.title, 0, info.title.length(), rect); int textWidth = rect.width(); int textHeight = rect.height(); // 文字距左边的距离 float textX = left + 40; // 计算baseline，中文情况下为文字的底部 float textY = top + (headerHeight + textHeight)/2; c.drawText(info.title, textX, textY, paint); &#125; // 根据所在列表的位置计算所属分组的信息 public interface GroupInfoCallback &#123; GroupInfo getGroupInfo(int position); &#125;&#125; 分组信息的Model类 12345678910111213141516171819202122package com.him.stickyheader;public class GroupInfo &#123; // 分组的id public int groupId; // 分组显示的title public String title; // 在分组中的位置 public int position; // 分组的大小 public int groupSize; // 是否是分组的第一个 public boolean isFirstItem() &#123; return position == 0; &#125; // 是否是分组的最后一个 public boolean isLastItem() &#123; return position == (groupSize - 1); &#125;&#125; Activity布局 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:background=&quot;#b5b8de&quot;&gt; &lt;!--设置和item不同的背景色，当做divider的颜色--&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; item布局 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 获取源代码扫描以下二维码关注我的微信公众号野猿新一，发送“悬停头部”获取源代码的下载方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
