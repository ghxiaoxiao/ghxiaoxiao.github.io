<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView.ItemDecoration实现StrickyHeader、粘性头部、悬停头部]]></title>
    <url>%2F2019%2F06%2F19%2FRecyclerView-ItemDecoration%E5%AE%9E%E7%8E%B0StrickyHeader%E3%80%81%E7%B2%98%E6%80%A7%E5%A4%B4%E9%83%A8%E3%80%81%E6%82%AC%E5%81%9C%E5%A4%B4%E9%83%A8%2F</url>
    <content type="text"><![CDATA[参考 RecyclerView探索之通过ItemDecoration实现StickyHeader效果这篇文章真是完美，写得非常清晰，一步步实现下来，看完真是茅塞顿开，以前一直以为这个知识点很难的。 Android 从零开始实现RecyclerView分组及粘性头部效果这篇文章貌似更牛逼，但是没深入去看 RecyclerView 悬浮/粘性头部——StickyHeaderDecoration 其实在GitHub上已经有很多开源的很成熟的StickyHeader项目 timehop/sticky-headers-recyclerview 先来实现效果镇楼 实现代码Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.him.stickyheader;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public List&lt;String&gt; datas; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView mRecyclerView = findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.addItemDecoration(new MyItemDecoration(new MyItemDecoration.GroupInfoCallback() &#123; // 根据全局数据的位置position查询所属分组的信息GroupInfo @Override public GroupInfo getGroupInfo(int position) &#123; // 测试数据，暂时10条数据一组 int size = 10; GroupInfo info = new GroupInfo(); info.groupId = position / size; info.title = info.groupId + &quot;&quot;; info.position = position % size; info.groupSize = size; return info; &#125; &#125;)); initDatas(); mRecyclerView.setAdapter(new MyAdapter(datas)); &#125; // 初始化测试数据 private void initDatas() &#123; datas = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100;i++) &#123; datas.add(&quot;test &quot; + i); &#125; &#125;&#125; Adapter 1234567891011121314151617181920212223242526272829303132333435363738394041package com.him.stickyheader;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; public List&lt;String&gt; datas; public MyAdapter(List&lt;String&gt; datas) &#123; this.datas = datas; &#125; @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View itemView = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item, viewGroup, false); return new MyViewHolder(itemView); &#125; @Override public void onBindViewHolder(@NonNull MyViewHolder viewHolder, int i) &#123; viewHolder.text.setText(datas.get(i)); &#125; @Override public int getItemCount() &#123; return datas == null ? 0 :datas.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView text; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); text = itemView.findViewById(R.id.text); &#125; &#125;&#125; ItemDecoration，这是最重要的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.him.stickyheader;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.View;import java.util.function.IntBinaryOperator;public class MyItemDecoration extends RecyclerView.ItemDecoration &#123; // 普通分割线的高度 private int dividerHeight = 1; // 分组header高度 private int headerHeight = 65; // 根据position获取分组信息的回调 private GroupInfoCallback callback; // 画笔 private Paint paint; public MyItemDecoration(GroupInfoCallback callback) &#123; this.callback = callback; paint = new Paint(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int itemPosition = parent.getChildAdapterPosition(view); GroupInfo info = callback.getGroupInfo(itemPosition); if (info.isFirstItem()) &#123; // 分组第一个item撑开一个header的高度 outRect.top = headerHeight; &#125; else &#123; // 其他item撑开一个普通divider的高度 outRect.top = dividerHeight; &#125; &#125; @Override public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123; super.onDraw(c, parent, state); // header左右边的坐标，注意考虑parent的左右padding float left = parent.getPaddingLeft(); float right = parent.getWidth() - parent.getPaddingRight(); // 循环RecyclerView中当前可见的View for (int i = 0; i &lt; parent.getChildCount(); i++) &#123; View child = parent.getChildAt(i); // 根据当前view获取在整个列表中的位置 int itemPosition = parent.getChildAdapterPosition(child); // 根据position获取所属分组的信息 GroupInfo info = callback.getGroupInfo(itemPosition); // 重点来了，敲黑板 // 注意这里的i表示在RecyclerView当前可见View中的位置（第几个） // i == 0表示当前可见的第一个View // 这里绘制分组标题悬停的效果 if (i == 0) &#123; // 分组标题停在最顶部，就是parent的顶部，然后再考虑顶部的padding float top = parent.getPaddingTop(); // top加分组高度就是底部坐标 float bottom = top + headerHeight; // 这里是第二个重点 // 如果没这段代码，就无法实现下面的分组标题把当前悬停的分组标题往上推出页面的效果 // 分组的最后一个item且该item的底部坐标小于悬停顶部的header的底部坐标的情况下，需执行以下代码，重新计算header的位置 if (info.isLastItem() &amp;&amp; bottom &gt; child.getBottom()) &#123; bottom = child.getBottom(); top = bottom - headerHeight; &#125; drawHeader(left, top, right, bottom, c, info); &#125; else if (info.isFirstItem()) &#123; // 如果不是可见的第一个view但是是分组的第一个item，则绘制分组标题 // item的顶部再往上一个header的高度 float top = child.getTop() - headerHeight; // 顶部坐标加上header高度就是底部坐标 float bottom = top + headerHeight; drawHeader(left, top, right, bottom, c, info); &#125; &#125; &#125; // 根据计算出的header位置绘制header及header中的title private void drawHeader(float left, float top, float right, float bottom, Canvas c, GroupInfo info) &#123; // 设置header背景色，然后绘制 paint.setColor(Color.GREEN); c.drawRect(left, top, right, bottom, paint); // 设置title文字大小，然后计算文字高度，用于接下来计算文字绘制的位置 paint.setTextSize(32); paint.setColor(Color.BLUE); Rect rect = new Rect(); // 计算要绘制的文字的宽高 paint.getTextBounds(info.title, 0, info.title.length(), rect); int textWidth = rect.width(); int textHeight = rect.height(); // 文字距左边的距离 float textX = left + 40; // 计算baseline，中文情况下为文字的底部 float textY = top + (headerHeight + textHeight)/2; c.drawText(info.title, textX, textY, paint); &#125; // 根据所在列表的位置计算所属分组的信息 public interface GroupInfoCallback &#123; GroupInfo getGroupInfo(int position); &#125;&#125; 分组信息的Model类 12345678910111213141516171819202122package com.him.stickyheader;public class GroupInfo &#123; // 分组的id public int groupId; // 分组显示的title public String title; // 在分组中的位置 public int position; // 分组的大小 public int groupSize; // 是否是分组的第一个 public boolean isFirstItem() &#123; return position == 0; &#125; // 是否是分组的最后一个 public boolean isLastItem() &#123; return position == (groupSize - 1); &#125;&#125; Activity布局 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:background=&quot;#b5b8de&quot;&gt; &lt;!--设置和item不同的背景色，当做divider的颜色--&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; item布局 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 获取源代码扫描以下二维码关注我的微信公众号野猿新一，发送“悬停头部”获取源代码的下载方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
