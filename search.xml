<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java生成UUID]]></title>
    <url>%2F2019%2F07%2F06%2Fjava%E7%94%9F%E6%88%90UUID%2F</url>
    <content type="text"><![CDATA[简介UUID是通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。另外我们也可以在e2fsprogs包中的UUID库找到实现。 总之一句话，保证在不同时间、不同地点、不同设备上产生的UUID的唯一性，不重复。 Java生成UUID在java中有现成的api可以直接生成UUID 123456System.out.println(UUID.randomUUID().toString());System.out.println(UUID.randomUUID().toString());System.out.println(UUID.randomUUID().toString());System.out.println(UUID.randomUUID().toString());System.out.println(UUID.randomUUID().toString());System.out.println(UUID.randomUUID().toString()); 生成的结果每次都不一样，比如 12345647992182-32cc-4979-88b8-ee1db54b0172f6162463-4f26-4520-ba4f-f853fb5f8c99104a8450-7c8f-4c34-839d-5d5902b9cc90f97389f9-81e6-406e-820a-1da96a68ddac59a6dc1a-07d6-467b-a6df-eb11207fa16843daf170-1f79-4e8c-af22-001c32c045c2 可看出生成的UUID格式是这样的xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx，位数为8-4-4-4-12共32位16进制，中间用”-“号隔开 如果想单纯返回32位16进制，可以用replace去掉“-”号 123456System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;));System.out.println(UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;)); 返回结果如下 123456df12e44ebc3a420c808cdcdc6e650c6dfdfd016ccbf644e29ccc81e589eeca90bb08a994992f46feadde1aa5764816350cc5d367b8024cbcaa8441e4284c1e3ab7c7ba6bc422456c98226d8ce5cff1f5c17e81750471463ca064cc2efcf3849e]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 如何录屏]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-Studio-%E5%A6%82%E4%BD%95%E5%BD%95%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[首先连接手机或者打开模拟器，然后打开要录制的App 在Android Studio底部找到Logcat切换到Logcat面板，然后点击左边的录屏的小按钮 在弹出的对话框中点击Start Recording开始录制 下图表示录制中，若想结束录制直接点右边的Stop Recording按钮 在弹出的保存对话框中选择保存路径，设置保存文件的名称，最后点击OK按钮保存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 如何对应用截屏]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-Studio-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%94%E7%94%A8%E6%88%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[首先要连接手机，然后进入到你要截屏的页面 然后在Android Studio中切换到Logcat，然后点击左边的相机图标 在弹出的页面中可以预览要截屏的页面，点击右下角的保存按钮 最后选择要保存的路径，点击OK按钮即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android gradle用exclude排除引用包中的dependency引用]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-gradle%E7%94%A8exclude%E6%8E%92%E9%99%A4%E5%BC%95%E7%94%A8%E5%8C%85%E4%B8%AD%E7%9A%84dependency%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[项目突然编译不通过，报如下错误 1234567891011121314FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:transformDexArchiveWithExternalLibsDexMergerForDebug'.&gt; com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives: D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\104.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\115.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\93.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\39.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\12.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\21.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\47.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\4.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\5.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\22.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\14.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\30.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\31.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\13.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\48.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\10.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\19.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\49.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\6.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\23.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\11.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\41.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\24.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\7.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\34.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\17.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\26.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\42.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\51.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\25.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\43.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\8.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\52.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\27.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\0.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\44.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\18.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\35.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\9.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\45.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\28.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\15.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\1.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\2.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\32.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\46.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\16.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\29.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\3.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\50.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\20.jar Program type already present: android.support.v4.widget.SlidingPaneLayout$AccessibilityDelegate Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes.* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 19s 经排查发现原来是项目中引用的第三方包’liji.library.dev:citypickerview:4.1.1’中引用的v7包和项目引用的v7包冲突导致的。 可以直接删除项目的v7包引用，直接用第三包里面的v7包就可以了。 但是如果第三方包引用的包太老旧，你执意要用最新的，那该怎么办呢？你可以用exclude把第三方包里的指定dependency排除掉，然后再重新编译就可以成功了。 123456dependencies &#123; implementation 'com.android.support:appcompat-v7:28.0.0' implementation ('liji.library.dev:citypickerview:4.1.1') &#123; exclude group: 'com.android.support' &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 编译报Run with --stacktrace option to get the stack trace]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E7%BC%96%E8%AF%91%E6%8A%A5Run-with-stacktrace-option-to-get-the-stack-trace%2F</url>
    <content type="text"><![CDATA[Android开发在编译过程中经常会报类似如下的错误，突如其来经常会让我们不知所措。这时候最需要的就是静下心来，照着报错的提示排查问题。 123456789101112131415FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:transformDexArchiveWithExternalLibsDexMergerForDebug'.&gt; com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives: D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\77.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\80.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\81.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\82.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\79.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\74.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\73.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\76.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\75.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\78.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\17.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\26.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\25.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\12.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\8.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\21.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\4.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\5.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\27.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\0.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\22.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\14.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\30.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\31.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\13.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\18.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\9.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\28.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\10.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\15.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\1.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\2.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\19.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\6.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\23.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\11.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\16.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\29.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\3.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\24.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\7.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\20.jar, D:\ws\AutosizingTest\app\build\intermediates\transforms\dexBuilder\debug\72.jar Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes. Program type already present: com.google.gson.FieldAttributes* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 17s39 actionable tasks: 15 executed, 24 up-to-date Run with –stacktrace option to get the stack trace. Run with –info or –debug option to get more log output. Run with –scan to get full insights.这句话是重点，但是说得不明不白的也不知道要怎么操作。 其实很简单，首先在Android Studio找到Terminal控制台（这个其实和CMD命令行控制台是一样的） 然后在控制台中输入如下指令，就可以重新编译debug版本，且带参数–stacktrace编译，如果编译失败会有失败的路径信息。 1gradlew compileDebug --stacktrace 或者–info和–debug参数也用上会打印更多的log信息。 1gradlew compileDebug --stacktrace --info --debug]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 四舍五入BigDecimal.ROUND_HALF_DOWN和BigDecimal.ROUND_HALF_UP的区别]]></title>
    <url>%2F2019%2F07%2F06%2Fjava-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5BigDecimal-ROUND-HALF-DOWN%E5%92%8CBigDecimal-ROUND-HALF-UP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[BigDecimal.ROUND_HALF_DOWN最贴切的说法应该是叫五舍六入，舍弃的部分如果大于5才进位，小于或等于5直接舍弃。 BigDecimal.ROUND_HALF_UP就是我们小学教的四舍五入，舍弃的部分如果大于等于5就进位，小于5的直接舍弃。 直接写几行代码输出验证下就很清楚了 注意方法setScale第一个参数为保留小数点后的位数 123456System.out.println("BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_UP));System.out.println("BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_UP));System.out.println("BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_UP)); 输出结果为 123456BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN)=1.23BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN)=1.23BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN)=1.24BigDecimal.valueOf(1.234).setScale(2,BigDecimal.ROUND_HALF_UP)=1.23BigDecimal.valueOf(1.235).setScale(2,BigDecimal.ROUND_HALF_UP)=1.24BigDecimal.valueOf(1.236).setScale(2,BigDecimal.ROUND_HALF_UP)=1.24 再看下操作负数 123456System.out.println("BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN)="+BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN));System.out.println("BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_UP));System.out.println("BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_UP));System.out.println("BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_UP)="+BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_UP)); 输出结果为 123456BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_DOWN)=-1.23BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_DOWN)=-1.23BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_DOWN)=-1.24BigDecimal.valueOf(-1.234).setScale(2,BigDecimal.ROUND_HALF_UP)=-1.23BigDecimal.valueOf(-1.235).setScale(2,BigDecimal.ROUND_HALF_UP)=-1.24BigDecimal.valueOf(-1.236).setScale(2,BigDecimal.ROUND_HALF_UP)=-1.24 可以看出所谓的down和up是相对0点的，down就是选择靠近0那边的数，up就是选择远离0一边的数 比如1.235，靠近0那边的是1.23，远离0的是1.24，用BigDecimal.ROUND_HALF_DOWN处理就选择靠近0那边的1.23，用BigDecimal.ROUND_HALF_UP处理就选择远离0的1.24 再比如-1.235，靠近0那边的是-1.23，远离0的是-1.24，用BigDecimal.ROUND_HALF_DOWN处理就选择靠近0那边的-1.23，用BigDecimal.ROUND_HALF_UP处理就选择远离0的-1.24 也可以这样说，down就是选择绝对值小的那个（绝对值越小越靠近0），up就是选择绝对值大的那个（绝对值越大越远离0）]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 四舍五入new BigDecimal(double)及BigDecimal valueOf(double)的区别]]></title>
    <url>%2F2019%2F07%2F06%2Fjava-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5new-BigDecimal-double-%E5%8F%8ABigDecimal-valueOf-double-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近在研究java的四舍五入，其中有一个方法如下 1new BigDecimal(val).setScale(newScale, BigDecimal.ROUND_HALF_DOWN)); 其中val是要处理的浮点数 newScale表示要保留小数点后几位 BigDecimal.ROUND_HALF_DOWN表示若舍弃的部分&gt;0.5则进位，否则直接舍弃，说白了就是五舍六入 比如说1.234，保留两位小数处理结果为1.23 比如说1.235，保留两位小数处理结果为1.23 比如说1.236，保留两位小数处理结果为1.24 为了验证我的猜测，马上写几行代码验证下 123System.out.println(new BigDecimal(1.234).setScale(2, BigDecimal.ROUND_HALF_DOWN));System.out.println(new BigDecimal(1.235).setScale(2, BigDecimal.ROUND_HALF_DOWN));System.out.println(new BigDecimal(1.236).setScale(2, BigDecimal.ROUND_HALF_DOWN)); 发现第二条结果与我的猜测不一致，感觉有点受伤 1231.231.241.24 1.235小数点后三位为5，明明是要舍弃的，为何进位了，难道网上的教程都是骗人 折腾了好久，最后发现原来我的写法跟网上别人的还是有细微差别 我的是：new BigDecimal(1.235).setScale(2, BigDecimal.ROUND_HALF_DOWN) 别人家的是：new BigDecimal(“1.235”).setScale(2, BigDecimal.ROUND_HALF_DOWN)，这样的写法结果确实是1.23 可是为何同样的数值，传double类型不行，传String就可以？难道这两种方法初始化的BigDecimal大小不一样？打印出来发现确实不一样 1234// 打印结果为1.2350000000000000976996261670137755572795867919921875 System.out.println(new BigDecimal(1.235).toString());// 打印结果为1.235System.out.println(new BigDecimal("1.235").toString()); new BigDecimal(1.235)的真实值为1.2350000000000000976996261670137755572795867919921875这一长串数字，舍弃的部分是大于0.5的，所以才进位的。 所以为了避免得到错误的结果还是建议传String类型的值，如果是double类型就用如下方法先转成String再处理 12new BigDecimal(String.valueOf(1.235)).setScale(2, BigDecimal.ROUND_HALF_DOWN);new BigDecimal(Double.toString(1.235)).setScale(2, BigDecimal.ROUND_HALF_DOWN); 还有另一种方法是直接传double类型的 1BigDecimal.valueOf(1.235).setScale(2, BigDecimal.ROUND_HALF_DOWN); 查看BigDecimal.valueOf源码，其内部实现其实也是先转成String 123456789101112131415161718192021222324/** * Translates a &#123;@code double&#125; into a &#123;@code BigDecimal&#125;, using * the &#123;@code double&#125;&apos;s canonical string representation provided * by the &#123;@link Double#toString(double)&#125; method. * * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This is generally the preferred way to convert * a &#123;@code double&#125; (or &#123;@code float&#125;) into a * &#123;@code BigDecimal&#125;, as the value returned is equal to that * resulting from constructing a &#123;@code BigDecimal&#125; from the * result of using &#123;@link Double#toString(double)&#125;. * * @param val &#123;@code double&#125; to convert to a &#123;@code BigDecimal&#125;. * @return a &#123;@code BigDecimal&#125; whose value is equal to or approximately * equal to the value of &#123;@code val&#125;. * @throws NumberFormatException if &#123;@code val&#125; is infinite or NaN. * @since 1.5 */public static BigDecimal valueOf(double val) &#123; // Reminder: a zero double returns &apos;0.0&apos;, so we cannot fastpath // to use the constant ZERO. This might be important enough to // justify a factory approach, a cache, or a few private // constants, later. return new BigDecimal(Double.toString(val));&#125; 总结用BigDecimal处理浮点数时BigDecimal的初始化最好采用如下方法 12double d = 1.235;BigDecimal bd = BigDecimal.valueOf(d);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java Math.floor()、Math.ceil()和Math.round()四舍五入的使用及区别]]></title>
    <url>%2F2019%2F07%2F06%2FJava-Math-floor-%E3%80%81Math-ceil-%E5%92%8CMath-round-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Math.floor()、Math.ceil()和Math.round()都是对浮点数取整（floor和ceil返回不带小数的double，round返回long） floor字面意思为地板，返回的是小于或等于该数值的最大的整数 ceil字面意思是天花板，返回的是大于或等于该值的最小的整数 round就是我们常见的四舍五入，不再多说 直接看下demo及运行结果 123456789101112131415161718192021222324252627282930public class Test4 &#123; public static void main(String[] args) &#123; System.out.println("Math.floor(1.0) = " + Math.floor(1.0)); System.out.println("Math.floor(1.4) = " + Math.floor(1.4)); System.out.println("Math.floor(1.5) = " + Math.floor(1.5)); System.out.println("Math.floor(1.6) = " + Math.floor(1.6)); System.out.println("Math.floor(-1.0) = " + Math.floor(-1.0)); System.out.println("Math.floor(-1.4) = " + Math.floor(-1.4)); System.out.println("Math.floor(-1.5) = " + Math.floor(-1.5)); System.out.println("Math.floor(-1.6) = " + Math.floor(-1.6)); System.out.println("Math.ceil(1.0) = " + Math.ceil(1.0)); System.out.println("Math.ceil(1.4) = " + Math.ceil(1.4)); System.out.println("Math.ceil(1.5) = " + Math.ceil(1.5)); System.out.println("Math.ceil(1.6) = " + Math.ceil(1.6)); System.out.println("Math.ceil(-1.0) = " + Math.ceil(-1.0)); System.out.println("Math.ceil(-1.4) = " + Math.ceil(-1.4)); System.out.println("Math.ceil(-1.5) = " + Math.ceil(-1.5)); System.out.println("Math.ceil(-1.6) = " + Math.ceil(-1.6)); System.out.println("Math.round(1.0) = " + Math.round(1.0)); System.out.println("Math.round(1.4) = " + Math.round(1.4)); System.out.println("Math.round(1.5) = " + Math.round(1.5)); System.out.println("Math.round(1.6) = " + Math.round(1.6)); System.out.println("Math.round(-1.0) = " + Math.round(-1.0)); System.out.println("Math.round(-1.4) = " + Math.round(-1.4)); System.out.println("Math.round(-1.5) = " + Math.round(-1.5)); System.out.println("Math.round(-1.6) = " + Math.round(-1.6)); &#125;&#125; 运行结果 123456789101112131415161718192021222324Math.floor(1.0) = 1.0Math.floor(1.4) = 1.0Math.floor(1.5) = 1.0Math.floor(1.6) = 1.0Math.floor(-1.0) = -1.0Math.floor(-1.4) = -2.0Math.floor(-1.5) = -2.0Math.floor(-1.6) = -2.0Math.ceil(1.0) = 1.0Math.ceil(1.4) = 2.0Math.ceil(1.5) = 2.0Math.ceil(1.6) = 2.0Math.ceil(-1.0) = -1.0Math.ceil(-1.4) = -1.0Math.ceil(-1.5) = -1.0Math.ceil(-1.6) = -1.0Math.round(1.0) = 1Math.round(1.4) = 1Math.round(1.5) = 2Math.round(1.6) = 2Math.round(-1.0) = -1Math.round(-1.4) = -1Math.round(-1.5) = -1Math.round(-1.6) = -2 需要注意的是正负值处理后的结果 比如 Math.floor(1.5) = 1.0，Math.floor(-1.5) = -2.0 Math.ceil(1.5) = 2.0，Math.ceil(-1.5) = -1.0 Math.round(1.5) = 2，Math.round(-1.5) = -1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android dp和px互转、sp和px互转及背后的原理]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-dp%E5%92%8Cpx%E4%BA%92%E8%BD%AC%E3%80%81sp%E5%92%8Cpx%E4%BA%92%E8%BD%AC%E5%8F%8A%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[先上代码，拿来即用 12345678910111213141516171819202122232425262728293031/** * dp转px */public static int dp2px(Context context, float dp) &#123; float density = context.getResources().getDisplayMetrics().density; return (int) (dp * density + 0.5f);&#125;/** * sp转px */public static int sp2px(Context context, float sp) &#123; float scaledDensity = context.getResources().getDisplayMetrics().scaledDensity; return (int) (sp * scaledDensity + 0.5f);&#125;/** * px转dp */public static int px2dp(Context context, float px) &#123; float density = context.getResources().getDisplayMetrics().density; return (int) (px / density + 0.5f);&#125;/** * px转sp */public static int px2sp(Context context, float px) &#123; float scaledDensity = context.getResources().getDisplayMetrics().scaledDensity; return (int) (px / scaledDensity + 0.5f);&#125; 源码解析关于dp和px、sp和px的互转，网上很多都是这样写的，很多人都是copy过来直接使用，但是有没有人想过为什么呢? 其实Android原生Api有提供dip和sp转px的方法，使用如下： 1234// 10dp转pxTypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, context.getResources().getDisplayMetrics());// 10sp转pxTypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 10, context.getResources().getDisplayMetrics()); 我们再看下TypedValue.applyDimension()方法的源码 1234567891011121314151617181920212223242526272829303132/** * Converts an unpacked complex data value holding a dimension to its final floating * point value. The two parameters &lt;var&gt;unit&lt;/var&gt; and &lt;var&gt;value&lt;/var&gt; * are as in &#123;@link #TYPE_DIMENSION&#125;. * * @param unit The unit to convert from. * @param value The value to apply the unit to. * @param metrics Current display metrics to use in the conversion -- * supplies display density and scaling information. * * @return The complex floating point value multiplied by the appropriate * metrics depending on its unit. */public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; 看了以上源码是不是瞬间就明白了dp2px和sp2px的原理，只要看以上源码的第二和第三个case px = dp * density px = sp * scaledDensity 然后我们又可以反推出 dp = px / density sp = px / scaledDensity 为什么还要加0.5可能有人会问了，为什么我们开头的dp2px、sp2px、px2dp、px2sp四个方法里都还要加0.5？ 其实也可以不加0.5，如果返回值是float的话 12345678910111213141516171819202122232425262728293031/** * dp转px */public static float dp2px(Context context, float dp) &#123; float density = context.getResources().getDisplayMetrics().density; return dp * density;&#125;/** * sp转px */public static float sp2px(Context context, float sp) &#123; float scaledDensity = context.getResources().getDisplayMetrics().scaledDensity; return sp * scaledDensity;&#125;/** * px转dp */public static float px2dp(Context context, float px) &#123; float density = context.getResources().getDisplayMetrics().density; return px / density;&#125;/** * px转sp */public static float px2sp(Context context, float px) &#123; float scaledDensity = context.getResources().getDisplayMetrics().scaledDensity; return px / scaledDensity;&#125; 但是Android中很多有关尺寸的设置都是px，且是int类型，比如view.setWidth()、view.setHeight()的参数都是int类型，所以更多时候我们需要用到的是int类型。 那么如果要转化为int类型就需要加上0.5达到四舍五入的效果。 那么问题又来了，为什么加上0.5就可以四舍五入呢？举个栗子 java中浮点型强制类型转换成int类型是没有四舍五入的，而是直接把小数点后的值直接去掉 123456i1 = (int) 1.0; // 结果为1i2 = (int) 1.1; // 结果为1i3 = (int) 1.4; // 结果为1i4 = (int) 1.5; // 结果为1i5 = (int) 1.6; // 结果为1i6 = (int) 1.9; // 结果为1 如果加上0.5再转换，看下结果 123456i1 = (int) (1.0 + 0.5); // 结果为1i2 = (int) (1.1 + 0.5); // 结果为1i3 = (int) (1.4 + 0.5); // 结果为1i4 = (int) (1.5 + 0.5); // 结果为2i5 = (int) (1.6 + 0.5); // 结果为2i6 = (int) (1.9 + 0.5); // 结果为2 只要小数点后一位大于等于5再加上0.5就会达到五入的效果，得到更精确的值。这也就是为什么要加0.5的原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android通过代码主动弹出或隐藏输入法软键盘]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%B8%BB%E5%8A%A8%E5%BC%B9%E5%87%BA%E6%88%96%E9%9A%90%E8%97%8F%E8%BE%93%E5%85%A5%E6%B3%95%E8%BD%AF%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[软键盘的弹出一般是在用户点击Edittext获取焦点后自动弹出，隐藏的话是用户主动点击软件盘上的向下收起按钮或完成按钮后软件盘会收起来。 但是有时候我们有这样的需求，比如说点击某个按钮弹出软键盘，点击另一个按钮收起软键盘。这是候就需要通过InputMethodManager来实现。 先看下实现的效果： 弹出软键盘1234567public static void showSoftInput(Context context, View view) &#123; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); if (view != null &amp;&amp; imm != null)&#123; imm.showSoftInput(view, 0); // imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT); // 或者第二个参数传InputMethodManager.SHOW_IMPLICIT &#125;&#125; 需要注意的是传入的View必须是Editext等能够获取焦点接收软件盘输入的控件才有效果，比如传入Button控件的话就无法弹出软键盘。 对于InputMethodManager.showSoftInput(View view, int flags)方法的第二个参数，看源码注释说可以传入0或者InputMethodManager.SHOW_IMPLICIT。我实际测试都可以弹出软键盘，目前还未发现有何区别。 该方法源码如下 12345678910111213/** * Synonym for &#123;@link #showSoftInput(View, int, ResultReceiver)&#125; without * a result receiver: explicitly request that the current input method's * soft input area be shown to the user, if needed. * * @param view The currently focused view, which would like to receive * soft keyboard input. * @param flags Provides additional operating flags. Currently may be * 0 or have the &#123;@link #SHOW_IMPLICIT&#125; bit set. */public boolean showSoftInput(View view, int flags) &#123; return showSoftInput(view, flags, null);&#125; 收起软键盘1234567public static void hideSoftInput(Context context, View view) &#123; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); if (view != null &amp;&amp; imm != null)&#123; imm.hideSoftInputFromWindow(view.getWindowToken(), 0); // imm.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_IMPLICIT_ONLY); // 或者第二个参数传InputMethodManager.HIDE_IMPLICIT_ONLY &#125;&#125; 收起软键盘传入的View参数没要求一定要是Edittext，只要是当前页面的任意View都可以，比如我传入DecorView照样可以弹出软键盘hideSoftInput(context, getWindow().getDecorView())。 对于InputMethodManager.hideSoftInputFromWindow(IBinder windowToken, int flags)方法的第二个参数，看源码注释说可以传入0或者InputMethodManager.HIDE_IMPLICIT_ONLY。根据源码注释和测试可以知道这两者的区别： 设置成0的话，不管软键盘是由用户点击Edittext后弹出的还是通过调用代码弹出的，都可以收起来。 设置成InputMethodManager.HIDE_IMPLICIT_ONLY的话，用户点击Edittext弹出的软键盘可以收起来，但是通过代码弹出的软键盘无法收起。 InputMethodManager.hideSoftInputFromWindow的源码如下： 12345678910111213/** * Synonym for &#123;@link #hideSoftInputFromWindow(IBinder, int, ResultReceiver)&#125; * without a result: request to hide the soft input window from the * context of the window that is currently accepting input. * * @param windowToken The token of the window that is making the request, * as returned by &#123;@link View#getWindowToken() View.getWindowToken()&#125;. * @param flags Provides additional operating flags. Currently may be * 0 or have the &#123;@link #HIDE_IMPLICIT_ONLY&#125; bit set. */public boolean hideSoftInputFromWindow(IBinder windowToken, int flags) &#123; return hideSoftInputFromWindow(windowToken, flags, null);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 编译报XML declaration not well-formed错误的解决方法]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E7%BC%96%E8%AF%91%E6%8A%A5XML-declaration-not-well-formed%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[项目上一秒还运行得好好的，下一秒编译却突然不成功，报如下错误 12345678910111213141516171819FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':app:mergeDebugResources'.&gt; java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: Android resource compilation failed Output: D:\ws\AutosizingTest\app\src\main\res\layout\activity_main.xml:1: error: XML declaration not well-formed. Command: C:\Users\Him\.gradle\caches\transforms-1\files-1.1\aapt2-3.2.1-4818971-windows.jar\4fc997b490c0c003506edf14eef98945\aapt2-3.2.1-4818971-windows\aapt2.exe compile --legacy \ -o \ D:\ws\AutosizingTest\app\build\intermediates\res\merged\debug \ D:\ws\AutosizingTest\app\src\main\res\layout\activity_main.xml Daemon: AAPT2 aapt2-3.2.1-4818971-windows Daemon #0* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 1s 根据错误提示是布局文件错误，可是看了老半天没发现什么错误啊，而且布局文件也没动过啊 123456789&lt;?xml dversion="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;!--此处省略好多代码--&gt;&lt;/RelativeLayout&gt; 而且错误提示也是说的不清不楚的，无法定位问题的原因，这种情况你越急越找不到原因。 遇到问题不要总是想当然的认为自己代码没问题，自己什么也没有动，就开始骂mmp。这时候需要静下心来。 根据错误提示这句话activity_main.xml:1: error: XML declaration not well-formed可以知道问题肯定出在activity_main.xml，而且是在第一行，仔细一看发现这句话中version前多了一个d，导致了编译不通过。有可能是不小心按到键盘导致的。 所以遇到问题一定不要慌，事出必定有因，根据错误提示静下心来排查，肯定能找出问题的原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android adjustResize实现弹出软键盘不遮挡Edittext且顶部标题栏固定]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-adjustResize%E5%AE%9E%E7%8E%B0%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%E4%B8%8D%E9%81%AE%E6%8C%A1Edittext%E4%B8%94%E9%A1%B6%E9%83%A8%E6%A0%87%E9%A2%98%E6%A0%8F%E5%9B%BA%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[这里以一个简单的Demo演示下 界面如下所以 界面的XML如下所示 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="我是顶部的Button"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_above="@id/edit_text" android:text="我是底部的Button"/&gt; &lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:text="我是底部的Edittext"/&gt;&lt;/RelativeLayout&gt; 在点击底部的Edittext后弹出软键盘，软键盘把Edittext顶上去了，没有被遮挡，但是顶部的标题栏和按钮却被顶到了布局外看不见了，如下gif所示。这样的体验其实也不好，因为用户在输入的同时，有可能要操作标题栏上的ActionButton，但是此时标题已被顶出布局外，用户还要先收起软键盘，再去操作标题栏上的按钮。 这时候就该adjustResize上场了，我们可以在Manifest中设置Activity的android:windowSoftInputMode属性值为”adjustResize”，如下代码所示 1234&lt;activity android:name=".MainActivity" android:windowSoftInputMode="adjustResize"&gt;&lt;/activity&gt; 设置完的运行效果如gif图所示 Perfect，正是我们想要的效果，底部的内容被输入法往上顶，输入的时候不会被遮挡，顶部的标题栏又不会被顶出布局。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 通过父布局抢占Edittext焦点实现刚进入Activity不弹出软键盘]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E9%80%9A%E8%BF%87%E7%88%B6%E5%B8%83%E5%B1%80%E6%8A%A2%E5%8D%A0Edittext%E7%84%A6%E7%82%B9%E5%AE%9E%E7%8E%B0%E5%88%9A%E8%BF%9B%E5%85%A5Activity%E4%B8%8D%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在Android 进入Activity禁止弹出软键盘输入法及stateHidden和stateAlwaysHidden的区别这篇文章中我们通过设置Activity的android:windowSoftInputMode属性为stateHidden或者stateAlwaysHidden实现了进入Activity不马上弹出软键盘的功能，今天我们介绍另一种方法，通过父布局抢占Edittext焦点，从而不然软键盘弹出。 实现代码如下所示 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:focusableInTouchMode="true" android:focusable="true"&gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; 马上在我的魅族MX5手机上运行一下，发现软键盘是收起来了，但是却是在弹出后马上又收起来的。看起来就是软键盘闪了一下马上消失，这样的用户体验是很不好的。 既然这样的体验不好为什么网上一搜还是有很多人推荐这样的方法，唯一的可能就是他们看到的结果和我不一样，他们的手机上的运行结果可能确实是软键盘没有弹出来。 我马上用用Android模拟器试了下，发现模拟器上确实未弹出软键盘，不像在MX5手机上那样弹出又马上消失。 总结这种方法并不能保证对所有型号手机使用，所以不推荐使用。还是推荐Android官方推荐的方法，通过设置android:windowSoftInputMode属性来实现，具体参考这篇文章Android 进入Activity禁止弹出软键盘输入法及stateHidden和stateAlwaysHidden的区别。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 进入Activity主动弹出软键盘输入法及stateVisible和stateAlwaysVisible的区别]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E8%BF%9B%E5%85%A5Activity%E4%B8%BB%E5%8A%A8%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%B3%95%E5%8F%8AstateVisible%E5%92%8CstateAlwaysVisible%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在App开发中有些页面的功能定位就是搜索，用户进入该页面的唯一仅有的目的就是搜索，比如淘宝点击搜索框跳转的搜索商品页面，对于这种页面最好的设计就是一进入就把焦点定位在输入框，且弹出输入法，用户一进入进可以直接在软键盘上输入，而不必要再点一下输入框再弹出输入法。虽然是一个很细节的东西，但却是很好的用户体验。 废话这么多，该上代码了 123&lt;activity android:name=".MainActivity" android:windowSoftInputMode="stateVisible"/&gt; 还有另一个属性stateAlwaysVisible也可以实现同样的功能。 123&lt;activity android:name=".MainActivity" android:windowSoftInputMode="stateAlwaysVisible"/&gt; stateVisible和stateAlwaysVisible的区别既然stateVisible和stateAlwaysVisible都可以实现一进入Activity就弹出软键盘的功能，那么这两者又有什么区别呢？我们先看下谷歌官网的说明： stateVisible The soft keyboard is visible when that’s normally appropriate (when the user is navigating forward to the activity’s main window). stateAlwaysVisible The soft keyboard is made visible when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. 但是我个人觉得官网的解释有误（如果我的英语理解能力没错的话），对于stateAlwaysVisible，官网的说明是说从其他地方进入Activity的话，会弹出软件盘，如果是从其他页面返回的话是不会弹出的。 单我的理解是设置成stateAlwaysVisible的话，不管是往前进入，还是从其他页面返回，总是会弹出软键盘。 为了验证我的想法，我写了两个Activity验证下 MainActivity中有一个Edittext和一个Button，点击Button跳转到SecondActivity 首先先设置MainActibity的android:windowSoftInputMode=”stateVisible”，首先进入MainActivity，软键盘自动弹出，然后收起软键盘，点击Button跳转SecondActivity后再返回MainActivity，发现软键盘不弹出了。但是如果我们收起软键盘后不是进入SecondActivity再返回，而是按Home键返回左面再重新进入MainActivity，会发现输入法会重新弹出。 接下来设置MainActibity的android:windowSoftInputMode=”stateAlwaysVisible”，首先进入MainActivity，软键盘自动弹出，然后收起软键盘，点击Button跳转SecondActivity后再返回MainActivity，发现已经收起的软键盘会再次弹出来。这也验证了我的想法，说明官网的描述有误。 总结stateVisible：从其他页面或桌面往前进入该Activity，会弹出软件盘，如果是从其他页面返回该Activity，则已收起的软键盘不会再弹出。 stateAlwaysVisible：不管是从从其他页面或桌面往前进入该Activity，还是从其他页面返回该Activity，已收起的软键盘都会再弹出。 在代码中设置softInputMode当然，我们也可以在Activity的onCreate中设置softInputMode，如下代码所示，和在Manifest中设置是等价的 1234// 等价于android:windowSoftInputMode="stateVisible"getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);// 等价于android:windowSoftInputMode="stateAlwaysVisible"getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 进入Activity禁止弹出软键盘输入法及stateHidden和stateAlwaysHidden的区别]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E8%BF%9B%E5%85%A5Activity%E7%A6%81%E6%AD%A2%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%B3%95%E5%8F%8AstateHidden%E5%92%8CstateAlwaysHidden%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在开发中经常会遇到这样的问题，进入一个含Edittext的Activity后总是会自动弹出软件盘。但是有时候我们又不想让它弹出，因为影响美观，而且用户可能也会反感。最好的做法是刚进入时不让弹出，在用户输入的时候才让弹出，把主动权交个用户是对用户最大的尊重。 废话这么多，直接上代码 123&lt;activity android:name=".MainActivity" android:windowSoftInputMode="stateHidden"/&gt; 发现用stateAlwaysHidden也可以禁止弹出软键盘 123&lt;activity android:name=".MainActivity" android:windowSoftInputMode="stateAlwaysHidden"/&gt; stateHidden和stateAlwaysHidden的区别既然stateHidden和stateAlwaysHidden都可以实现禁止弹出软键盘，那这两者到底有什么区别呢？网上看很多人都说得不清不楚，还不如自己上Android官网看最权威 “stateHidden“ The soft keyboard is hidden when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. “stateAlwaysHidden“ The soft keyboard is always hidden when the activity’s main window has input focus. 发现官网的说明还是有点晦涩难懂的，我以我的理解说明下 stateHidden：当用户进入Activity后保证是隐藏软键盘的，但是如果是从另一个页面返回该页面就不能保证了。比如说用户进入A页面，然后在输入框输入内容，未收起软键盘直接进入B页面，再从B页面返回A页面，此时A页面中软键盘还是显示的。又或者是用户由A页面进入B页面，在B页面弹出软键盘，未收起直接返回A页面，此时A页面中软键盘还是显示的。 stateAlwaysHidden：当用户刚进入Activity后软键盘也是隐藏的。与stateHidden的区别是，还是以上面的例子来说明，比如说用户进入A页面，然后在输入框输入内容，未收起软键盘直接进入B页面，再从B页面返回A页面，此时A页面中软键盘是收起来的。又或者是用户由A页面进入B页面，在B页面弹出软键盘，未收起直接返回A页面，此时A页面中软键盘是收起来的。 在代码中设置softInputMode当然，我们也可以在Activity的onCreate中设置softInputMode，如下代码所示，和在Manifest中设置是等价的 1234// 等价于android:windowSoftInputMode="stateHidden"getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);// 等价于android:windowSoftInputMode="stateAlwaysHidden"getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Edittext 软键盘输入法的回车键设置成搜索按钮并监听点击事件]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-Edittext-%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E5%9B%9E%E8%BD%A6%E9%94%AE%E8%AE%BE%E7%BD%AE%E6%88%90%E6%90%9C%E7%B4%A2%E6%8C%89%E9%92%AE%E5%B9%B6%E7%9B%91%E5%90%AC%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[很多App中都有搜索功能，比如微信中的搜索好友，你会发现在页面中是没有搜索按钮的，而是软键盘的回车键变成了搜索按钮。这样设计其实挺好的，节省了页面空间，而且用户输入内容后直接在软件盘上单击搜索而无需再返回页面点击搜索按钮。 不说废话了，直接上代码： 首先先设置回车键为搜索按钮，记得 android:singleLine=”true”这句必不可少，否则无法生效 123456&lt;EditText android:id="@+id/edit_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:imeOptions="actionSearch" android:singleLine="true"/&gt; 然后设置回车键的点击事件监听 123456789101112EditText editText = findViewById(R.id.edit_text);editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEARCH) &#123; String keyword = v.getText().toString().trim(); Toast.makeText(MainActivity.this, keyword, Toast.LENGTH_SHORT).show(); return true; &#125; return false; &#125;&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Edittext设置软键盘输入法Enter回车键为完成按钮]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-Edittext%E8%AE%BE%E7%BD%AE%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%B3%95Enter%E5%9B%9E%E8%BD%A6%E9%94%AE%E4%B8%BA%E5%AE%8C%E6%88%90%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[软键盘中回车键默认功能是换行，单有时候我们想要实现的是点回车后收起软键盘，表示输入完成。比如登录页面中输完密码后点回车收起软件盘，然后登录。 示例代码代码很简单，如下所示，通过android:imeOptions=”actionDone”设置回车键为完成按钮，在不同的输入法中可能显示的内容会有不同，常见的会显示“完成”或者”Done”，点击完成按钮后软键盘会收起来。 还有一点别忘了，就是要设置android:singleLine=”true”，让Edittext只能输入一行，否则点击回车还是会换行。 12345&lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:imeOptions="actionDone" android:singleLine="true"/&gt; 当然，我们还可以在代码中设置，实现相同的效果。 123EditText editText = findViewById(R.id.edit_text);editText.setImeOptions(EditorInfo.IME_ACTION_DONE);editText.setSingleLine(); // 这句话也是必不可少的]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Edittext 软键盘输入法回车键改成下一步Next]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-Edittext-%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%B3%95%E5%9B%9E%E8%BD%A6%E9%94%AE%E6%94%B9%E6%88%90%E4%B8%8B%E4%B8%80%E6%AD%A5Next%2F</url>
    <content type="text"><![CDATA[软件盘中回车键默认功能是换行，但是有时候我们在Edittext中输完内容后点回车想要把焦点切到下一个Edittext继续输入，比如常见的登录页面，在输完用户名后，点回车调到输入密码输入框继续输入。 示例代码代码很简单，如下所示： 123456789101112131415161718&lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/account" android:layout_width="match_parent" android:layout_height="wrap_content" android:imeOptions="actionNext" android:singleLine="true"/&gt; &lt;EditText android:id="@+id/password" android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textPassword" android:imeOptions="actionDone" android:singleLine="true"/&gt;&lt;/LinearLayout&gt; 分析其实重点就以下两句话 android:imeOptions=”actionNext” android:singleLine=”true” android:imeOptions=”actionNext” 表示把回车键设置成下一步按钮，这里不同的输入法，不同的语言可能按钮上显示的文字会些许不同，比如有些手机上回显示下一步，有的显示下一个，有的英语输入法显示Next，意思大同小异。 android:singleLine=”true”意思是设置Edittext只能输入一行，要注意的这句话必不可少，否则android:imeOptions=”actionNext”的设置还是无法生效，点击回车还是会换行。想说用android:maxLines=”1”设置是不是也是等效的，结果发现还是会换行，只能用android:singleLine=”true”，虽然说android:singleLine属性已经被@Deprecated了。 nextFocusForward在上面的示例代码中，输完账号后点回车默认焦点是传递给下一个Edittext的。假设有三个Edittext，输完第一个后想跳过第二个Edittext直接输入第三个呢？这就需要靠nextFocusForward属性来实现 1234567891011121314151617181920212223242526&lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/edit1" android:layout_width="match_parent" android:layout_height="wrap_content" android:imeOptions="actionNext" android:nextFocusForward="@+id/edit3" android:singleLine="true"/&gt; &lt;EditText android:id="@+id/edit2" android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textPassword" android:imeOptions="actionNext" android:singleLine="true"/&gt; &lt;EditText android:id="@+id/edit3" android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textPassword" android:imeOptions="actionDone" android:singleLine="true"/&gt;&lt;/LinearLayout&gt; 代码很简单，关键看第一个Edittext中的android:nextFocusForward=”@+id/edit3”这句话，字面意思就是说下一个获取焦点的控件。需要注意设置的值写法是@+id/edit3而不是@id/edit3，少了加号的话无法编译成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 监听开机广播实现应用开机自启动]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E7%9B%91%E5%90%AC%E5%BC%80%E6%9C%BA%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[应用开机自启动的原理是监听开机广播android.intent.action.BOOT_COMPLETED，然后在BroadcastReceiver中打开应用 实现BroadcastReceiver首先实现一个BroadcastReceiver，该广播接收者监听”android.intent.action.BOOT_COMPLETED”广播，当接收到该广播时，打开该应用的启动页面。 123456789public class BootReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")) &#123; Intent toIntent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName()); context.startActivity(toIntent); &#125; &#125;&#125; 在Manifest中声明该广播接收者需要注意的是该广播接收者只能在Manifest中声明，而不能在代码中启动，否则无法接收到开机广播。 1234567&lt;receiver android:name=".base.BootReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 声明权限最后别忘了在Manifest中声明接收开机广播的权限，很多人都忘了这一步，导致无法接收到广播 1&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; 无法接收到广播这里列举下一些常见的无法接收到开机广播的原因： 未添加权限。 被系统自带或360手机助手等拦截，需在权限管理设置里放开开机自启动的权限。 应用安装到sd卡上，安装在sd卡上的应用是收不到BOOT_COMPLETED广播的。 系统开启了Fast Boot模式，这种模式下系统启动并不会发送BOOT_COMPLETED广播。 应用程序安装后重来没有启动过，这种情况下应用程序接收不到任何广播。]]></content>
  </entry>
  <entry>
    <title><![CDATA[adb shell 命令行模拟发送开机广播android.intent.action.BOOT_COMPLETED测试开机自启动]]></title>
    <url>%2F2019%2F07%2F06%2Fadb-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%8F%91%E9%80%81%E5%BC%80%E6%9C%BA%E5%B9%BF%E6%92%ADandroid-intent-action-BOOT-COMPLETED%E6%B5%8B%E8%AF%95%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[开发中需求需要监听开机广播android.intent.action.BOOT_COMPLETED，然后让应用开机自启动。以前测试总是傻傻的关机然后再开机再验证有没自启动，很浪费时间，现在发现原来可以通过adb shell命令模拟开机广播，记录下 模拟开机广播1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 当然你也可以直接指定自己定义BroadcastReceiver接收广播，如下 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.him.mypkg/com.him.mypkg.receiver.BootReceiver 权限拒绝在有写设备上可能会报类似java.lang.SecurityException: Permission Denial: not allowed to send broadcast android.intent.action.BOOT_COMPLETED from pid=3715, uid=2000这样的错误 遇到这个错误可以先执行adb root再执行发送广播的命令就可以了 12adb rootadb shell am broadcast -a android.intent.action.BOOT_COMPLETED 无法接收到广播无法接收到广播可能是以下几个原因造成的 未添加权限。 被系统自带或360手机助手等拦截，需在权限管理设置里放开开机自启动的权限。 应用安装到sd卡上，安装在sd卡上的应用是收不到BOOT_COMPLETED广播的。 系统开启了Fast Boot模式，这种模式下系统启动并不会发送BOOT_COMPLETED广播。 应用程序安装后重来没有启动过，这种情况下应用程序接收不到任何广播。 第一次安装无效，需重新启动 收不到广播，被系统拦截]]></content>
  </entry>
  <entry>
    <title><![CDATA[byte[]字节数组转hex16进制字符串的三种方法]]></title>
    <url>%2F2019%2F07%2F06%2Fbyte-%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BD%AChex16%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法1这种方法代码量是最少的，推荐 123private String bytesToHex(byte[] bytes) &#123; String hex = new BigInteger(1, bytes).toString(16);&#125; 方法21234567private String bytesToHex(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(); for (byte b : bytes) &#123; sb.append(String.format("%02x", b)); &#125; return sb.toString();&#125; 方法31234567891011public String bytesToHex(byte[] bytes) &#123; char[] hexDigits = &#123;'0','1','2','3','4','5','6','7','8','9', 'a','b','c','d','e','f'&#125;; // 一个字节对应两个16进制数，所以长度为字节数组乘2 char[] resultCharArray = new char[bytes.length * 2]; int index = 0; for (byte b : bytes) &#123; resultCharArray[index++] = hexDigits[b&gt;&gt;&gt;4 &amp; 0xf]; resultCharArray[index++] = hexDigits[b &amp; 0xf]; &#125; return new String(resultCharArray); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java String计算MD5的三种方法以及文件计算MD5的方法]]></title>
    <url>%2F2019%2F07%2F06%2Fjava-String%E8%AE%A1%E7%AE%97MD5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E8%AE%A1%E7%AE%97MD5%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MD5简介MD5，Message Digest Algorithm 5，是一种被广泛使用的信息摘要算法，可以将给定的任意长度数据通过一定的算法计算得出一个128位``二进制的散列值。 常见的表示方法是将128位二进制转成32位16进制，这样看起来比较简短。 方法1这种方法要注意一点的是不足32位高位需补零，否则会不足位，比如： 6531经MD5计算后正确的结果为0a7d83f084ec258aefd128569dda03d7 用方法1如果不高位补零返回的结果为a7d83f084ec258aefd128569dda03d7，前面的0少了 12345678910111213141516171819202122public static String MD51(String input) &#123; if(input == null || input.length() == 0) &#123; return null; &#125; try &#123; MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(input.getBytes()); byte[] byteArray = md5.digest(); BigInteger bigInt = new BigInteger(1, byteArray); // 参数16表示16进制 String result = bigInt.toString(16); // 不足32位高位补零 while(result.length() &lt; 32) &#123; result = "0" + result; &#125; return result; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null;&#125; 方法21234567891011121314151617181920212223public static String MD52(String input) &#123; if(input == null || input.length() == 0) &#123; return null; &#125; try &#123; MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(input.getBytes()); byte[] byteArray = md5.digest(); char[] hexDigits = &#123;'0','1','2','3','4','5','6','7','8','9', 'a','b','c','d','e','f'&#125;; // 一个字节对应两个16进制数，所以长度为字节数组乘2 char[] charArray = new char[byteArray.length * 2]; int index = 0; for (byte b : byteArray) &#123; charArray[index++] = hexDigits[b&gt;&gt;&gt;4 &amp; 0xf]; charArray[index++] = hexDigits[b &amp; 0xf]; &#125; return new String(charArray); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null;&#125; 方法31234567891011121314151617181920private static String MD53(String input) &#123; if(input == null || input.length() == 0) &#123; return null; &#125; try &#123; MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(input.getBytes()); byte[] byteArray = md5.digest(); StringBuilder sb = new StringBuilder(); for (byte b : byteArray) &#123; // 一个byte格式化成两位的16进制，不足两位高位补零 sb.append(String.format("%02x", b)); &#125; return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null;&#125; 计算文件的MD5值任何文件都可以计算MD5值，因为任何文件实际上就是字节数组 12345678910111213141516171819202122public static String fileToMD5(String path)&#123; try &#123; MessageDigest md5 = MessageDigest.getInstance("MD5"); FileInputStream fis = new FileInputStream(path); byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) &#123; md5.update(buffer, 0, len); &#125; fis.close(); byte[] byteArray = md5.digest(); StringBuilder sb = new StringBuilder(); for (byte b : byteArray) &#123; sb.append(String.format("%02x", b)); &#125; return sb.toString(); &#125; catch (IOException | NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; return null;&#125; 大写的MD5以上三种方法返回的MD5值包含的字母都是小写的，如果想返回大写的直接在方法返回前用toUpperCase就可以了，不再赘述 1234public static String MD5(String input) &#123; // 省略计算MD5代码 return result.toUpperCase();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java八进制、十进制、十六进制（hex）ASCII码字符串和String互转]]></title>
    <url>%2F2019%2F07%2F06%2Fjava%E5%85%AB%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%EF%BC%88hex%EF%BC%89ASCII%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CString%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[笔者在做Android串口开发的时候，与串口设备间的通信经常内容都是16进制的 发送命令的时候需要先把命令转成16进制的ASCII字符串。 接收到设备的反馈时需要把16进制的ASCII字符串转成对应的明文。 比如我们要发送的明文为ABCDEF，需要先转成对应的16进制ASCII码字符串414243444546 比如我们收到的反馈为16进制的ASCII码字符串313233343536，需要转成对应的明文123456 16进制ASCII码和单个字符char的互转我们先来了解单个字符char和ASCII码的互转 123456789101112// hex转char// 先将hex字符串转成intint i = Integer.parseInt("46", 16);// hex转char方法一，结果为FString str1 = new String(new char[]&#123;(char)i&#125;);// hex转char方法二，结果为FString str2 = new StringBuffer().append((char)i).toString();// char转hex方法一，结果为46（第二个参数16表16进制）String hex1 = Integer.toString(c, 16);// char转hex方法二，结果为46String hex2 = Integer.toHexString('F'); ASCII码hex字符串转String明文代码很简单，就是每两个字符表示的16进制ASCII码解析成一个明文字符 123456789101112public static String hex2Str(String hex) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; hex.length() - 1; i += 2) &#123; String h = hex.substring(i, (i + 2)); int decimal = Integer.parseInt(h, 16); sb.append((char) decimal); &#125; return sb.toString();&#125;// 输出结果为ABCDEFSystem.out.println(hex2Str("414243444546")); String明文转ASCII码hex字符串代码很简单，就是一个明文字符生成两个字符表示的16进制ASCII码 1234567891011121314public static String str2Hex(String str) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); // 这里的第二个参数16表示十六进制 sb.append(Integer.toString(c, 16)); // 或用toHexString方法直接转成16进制 // sb.append(Integer.toHexString(c)); &#125; return sb.toString();&#125;// 输出结果为414243444546System.out.println(str2Hex("ABCDEF")); 十进制ASCII码字符串和String明文互转10进制的转换和16进制的类似，只有细微的差别，直接看代码 10进制ASCII转String 12345678910111213public static String dec2Str(String ascii) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; ascii.length() - 1; i += 2) &#123; String h = ascii.substring(i, (i + 2)); // 这里第二个参数传10表10进制 int decimal = Integer.parseInt(h, 10); sb.append((char) decimal); &#125; return sb.toString();&#125;// 结果为ABCDEFSystem.out.println(dec2Str("656667686970")); String转10进制ASCII 1234567891011121314public static String str2Dec(String str) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); // 第二个参数10表示10进制 sb.append(Integer.toString(c, 10)); // 或者省略第二个参数，默认为10进制 // sb.append(Integer.toString(c)); &#125; return sb.toString();&#125;// 结果为656667686970System.out.println(str2Dec("ABCDEF")); 八进制ASCII码字符串和String明文互转八进制ASCII码的转换也类似，主要要注意的地方是八进制的ASCII码占三位，而16进制和十进制表示法只占两位 8进制ASCII转String 1234567891011121314public static String oct2Str(String ascii) &#123; StringBuilder sb = new StringBuilder(); // 这里这里循环的步进为3，因为8进制的ASCII码占3位 for (int i = 0; i &lt; ascii.length() - 2; i += 3) &#123; String h = ascii.substring(i, (i + 3)); // 第二个参数8表8进制 int decimal = Integer.parseInt(h, 8); sb.append((char) decimal); &#125; return sb.toString();&#125;// 结果为ABCDEFSystem.out.println(oct2Str("101102103104105106")); String转8进制ASCII 1234567891011121314public static String str2Oct(String str) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); // 这里的第二个参数8表8进制 sb.append(Integer.toString(c, 8)); // 或者直接用toOctalString方法转8进制 // sb.append(Integer.toOctalString(c)); &#125; return sb.toString();&#125;// 结果为101102103104105106System.out.println(str2Oct("ABCDEF"));]]></content>
  </entry>
  <entry>
    <title><![CDATA[英文大写字母A~Z，小写字母a~z对应的ASCII码快速查询]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%8B%B1%E6%96%87%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8DA-Z%EF%BC%8C%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8Da-z%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[在做开发的过程中经常会遇到用ASCII码表示的字母，或者字母要用ASCII码来表示。每次都要临时百度查ASCII表。 今天做个记录，以备下次用到。也方便大家查阅。 大写字母ASCII码 Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 小写字母ASCII码 Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 总结ASCII码大小写是不一样的，所以所有大小写字母总共对应52个ASCII码，有人会觉得52个这么多怎么记得住。其实也没必要记住，每次用到再临时查也很快。但总结下规律要记住也不是那么难。 大小写字母ASCII码是不一样的，比如大写字母A的ASCII码是65，小写字母a的ASCII码是97。 同样字母，大写字母的ASCII码值比小写字母的ASCII码值小，比如大写字母A的ASCII码值65比小写字母a的ASCII码值97小。 大写字母AZ的ASCII码值从6590，其实只要记住第一个A的ASCII码值65，后面的字母的ASCII码值累加上去就行了。 小写字母az的ASCII码值从97122，其实只要记住第一个a的ASCII码值97，后面的字母的ASCII码值累加上去就行了。 同样的字母，小写字母的ASCII码值比大写字母的ASCII码值大32，小写字母ASCII = 大写子ASCII + 32]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字0123456789对应的ASCII码值]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E5%AD%970123456789%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%80%BC%2F</url>
    <content type="text"><![CDATA[做开发的时候经常会遇到需要用ASCII码来表示数字，或者由ASCII码查找对应的数字 每个数字对应一个ASCII码值，也就十个值，但是记不住，每次都要百度查表 这里做个记录以备下次用到，也方便大家查询 Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 数字转ASCII码换算这里教大家一个小技巧，其实没必要记住10个数字对应的ASCII码。由于十个数字对应的ASCII码值是连续的，所以只要记住第一个值，后面的就知道了。 我们只需要记住数字0对应的ASCII码为48（十进制）就可以了，其余数字的ASCII码累加上去就行了。 记住一个简单的公式 x的ASCII码 = 48 + x，你想知道某个数字的ASCII码，直接用48加上这个数字值就对了 比如： 1的ASCII码 = 48 + 1 = 49 2的ASCII码 = 48 + 2 = 50 3的ASCII码 = 48 + 3 = 51 …… 9的ASCII码 = 48 + 9 = 57 如果需要知道其他进制的ASCII码的表示，直接用十进制ASCII码值换算下就可以了 ASCII码转数字换算同理，根据上面数字转ASCII码的公式 ASCII = 48 + x 可知，x = ASCII - 48 我们可以根据ASCII码值计算出所表示的数字，直接用该ASCII码值减去48所得结果就是表示的数字 比如： 49表示的数字 = 49 - 48 = 1 50表示的数字 = 50 - 48 = 1 51表示的数字 = 51 - 48 = 1 … 57表示的数字 = 57 - 48 = 9 是不是很简单呢，说了这么多其实你需要记住的就一个值48]]></content>
  </entry>
  <entry>
    <title><![CDATA[换行、回车、空格等常用的ASCII码值]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%8D%A2%E8%A1%8C%E3%80%81%E5%9B%9E%E8%BD%A6%E3%80%81%E7%A9%BA%E6%A0%BC%E7%AD%89%E5%B8%B8%E7%94%A8%E7%9A%84ASCII%E7%A0%81%E5%80%BC%2F</url>
    <content type="text"><![CDATA[换行符的ASCII码值为10，十六进制表示为0x0A 回车符的ASCII码值为13，十六进制表示为0x0D 空格符的ASCII码值为32，十六进制表示为0x20 以下列出其他一些常用到的符号的ASCII码 二进制 八进制 十进制 十六进制 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0001 1000 030 24 0x18 CAN (cancel) 取消 0010 0000 040 32 0x20 (space) 空格 完整的ASCII码表如果你想查看完整的ASCII码表，可以参考这篇文章 最全的ASCII码表，EASCII码表，ISO/IEC 8859码表二进制、八进制、十进制、十六进制快速查询]]></content>
  </entry>
  <entry>
    <title><![CDATA[最全的ASCII码表，EASCII码表，ISO/IEC 8859码表二进制、八进制、十进制、十六进制快速查询]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%9C%80%E5%85%A8%E7%9A%84ASCII%E7%A0%81%E8%A1%A8%EF%BC%8CEASCII%E7%A0%81%E8%A1%A8%EF%BC%8CISO-IEC-8859%E7%A0%81%E8%A1%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%81%E5%85%AB%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[查询ASCII码只有128个字符，在本页面直接按Ctrl+F输入你要查找的字符查询对应的ASCII吗，或者输入ASCII值（二进制、八进制、十进制、十六进制）查找对应的字符。 简介ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套计算机编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。 ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。 规律由ASCII码表我们可以做如下总结（以下说明均以10进制表示法）： 共定义了128个字符，其中33控制字符个字符无法显示，剩余95个可显示字符 控制字符包含0~31的32个字符，加上一个删除符（127）,共33个 可显示字符包含32~126的95个字符（包含数字、大小写字符、英文标点符号等） 数字19对应的ASCII码为4857 大写字母AZ对应的ASCII码为6590 小写字母az对应的ASCII码为97122 ASCII码表 Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans. block) 结束传输块 0001 1000 030 24 0x18 CAN (cancel) 取消 0001 1001 031 25 0x19 EM (end of medium) 媒介结束 0001 1010 032 26 0x1A SUB (substitute) 代替 0001 1011 033 27 0x1B ESC (escape) 换码(溢出) 0001 1100 034 28 0x1C FS (file separator) 文件分隔符 0001 1101 035 29 0x1D GS (group separator) 分组符 0001 1110 036 30 0x1E RS (record separator) 记录分隔符 0001 1111 037 31 0x1F US (unit separator) 单元分隔符 0010 0000 040 32 0x20 (space) 空格 0010 0001 041 33 0x21 ! 叹号 0010 0010 042 34 0x22 “ 双引号 0010 0011 043 35 0x23 # 井号 0010 0100 044 36 0x24 $ 美元符 0010 0101 045 37 0x25 % 百分号 0010 0110 046 38 0x26 &amp; 和号 0010 0111 047 39 0x27 ‘ 闭单引号 0010 1000 050 40 0x28 ( 开括号 0010 1001 051 41 0x29 ) 闭括号 0010 1010 052 42 0x2A * 星号 0010 1011 053 43 0x2B + 加号 0010 1100 054 44 0x2C , 逗号 0010 1101 055 45 0x2D - 减号/破折号 0010 1110 056 46 0x2E . 句号 0010 1111 057 47 0x2F / 斜杠 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 0011 1010 072 58 0x3A : 冒号 0011 1011 073 59 0x3B ; 分号 0011 1100 074 60 0x3C &lt; 小于 0011 1101 075 61 0x3D = 等号 0011 1110 076 62 0x3E &gt; 大于 0011 1111 077 63 0x3F ? 问号 0100 0000 0100 64 0x40 @ 电子邮件符号 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 0101 1011 0133 91 0x5B [ 开方括号 0101 1100 0134 92 0x5C \ 反斜杠 0101 1101 0135 93 0x5D ] 闭方括号 0101 1110 0136 94 0x5E ^ 脱字符 0101 1111 0137 95 0x5F _ 下划线 0110 0000 0140 96 0x60 ` 开单引号 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 0111 1011 0173 123 0x7B { 开花括号 0111 1100 0174 124 0x7C | 垂线 0111 1101 0175 125 0x7D } 闭花括号 0111 1110 0176 126 0x7E ~ 波浪号 0111 1111 0177 127 0x7F DEL (delete) 删除 ASCII码缺点ASCII的局限在于只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语（而且在处理英语当中，即使会违反拼写规则，外来词如naïve、café、élite等等时，所有重音符号都必须去掉）。虽然EASCII解决了部分西欧语言的显示问题，但对更多其他语言依然无能为力。因此有其他的扩展方案，如EASCII和ISO/IEC 8859，现在的软件系统大多采用Unicode。 EASCIIEASCII（Extended ASCII，扩展美国标准信息交换码）是将ASCII码由7位二进制扩充为8位而成。EASCII码比ASCII码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。 原来的ASCII码二进制表示范围为0000 0000~0111 1111（共128个字符），可以看到高八位都是0，是没有用到的。 而新增的EASCII二进制表示范围为1000 00001111 1111（十进制为129255，共128个字符），可以看到高八位都是1。 ISO/IEC 8859不过，EASCII码目前已经很少使用，常用的是ISO/IEC 8859字符编码方案。该方案与EASCII码类似，也同样是在ASCII码的基础上，利用了ASCII的7位编码所没有用到的最高位(首位)，将编码范围从原先ASCII码的0x000x7F(十进制为0127)，扩展到了0x800xFF(十进制为128255)。 ISO/IEC 8859字符编码方案所扩展的这128个编码中，实际上只有0xA00xFF(十进制为160255)被实际使用。也就是说，只有0xA00xFF(十进制为160255)这96个编码定义了字符，而0x800x9F(十进制为128159)这32个编码并未定义字符。 ISO/IEC 8859字符编码方案同样是单字节编码方案，也同样完全兼容ASCII。 符号 十六进制 十进制 表示方法 名称 00A0 160 NBSP 不换行空格 ¡ 00A1 161 ¡ 倒感叹号 ¢ 00A2 162 ¢ 英分 £ 00A3 163 £ 英镑 ¤ 00A4 164 ¤ 货币记号 ¥ 00A5 165 ¥ 人民币/日元 ¦ 00A6 166 ¦ 断竖线 § 00A7 167 § 小节符 ¨ 00A8 168 ¨ 分音符（元音变音） © 00A9 169 © 著作权符 ª 00AA 170 ª 阴性序数记号 « 00AB 171 « 左指双尖引号 ¬ 00AC 172 ¬ 非标记 00AD 173 SHY 选择性连接号 ® 00AE 174 ® 注册商标 ¯ 00AF 175 ¯ 长音符 ° 00B0 176 ° 度 ± 00B1 177 ± 正负号 ² 00B2 178 ² 二次方号 ³ 00B3 179 ³ 三次方号 ´ 00B4 180 ´ 锐音符 µ 00B5 181 µ 微符 ¶ 00B6 182 ¶ 段落标记 · 00B7 183 · 中心点 ¸ 00B8 184 ¸ 软音符 ¹ 00B9 185 ¹ 一次方号 º 00BA 186 º 阳性序数记号 » 00BB 187 » 右指双尖引号 ¼ 00BC 188 ¼ 四分之一 ½ 00BD 189 ½ 二分之一 ¾ 00BE 190 ¾ 四分之三 ¿ 00BF 191 ¿ 竖翻问号 À 00C0 192 À 带抑音符的A Á 00C1 193 Á 带锐音符的A Â 00C2 194 Â 带扬抑符的A Ã 00C3 195 Ã 带颚化符的A Ä 00C4 196 Ä 带分音符的A Å 00C5 197 Å 带上圆圈的A Æ 00C6 198 Æ 大写连字AE Ç 00C7 199 Ç 带下加符的C È 00C8 200 È 带抑音符的E É 00C9 201 É 带锐音符的E Ê 00CA 202 Ê 带扬抑符的E Ë 00CB 203 Ë 带分音符的E Ì 00CC 204 Ì 带抑音符的I Í 00CD 205 Í 带锐音符的I Î 00CE 206 Î 带扬抑符的I Ï 00CF 207 Ï 带分音符的I Ð 00D0 208 Ð 带横线符的D Ñ 00D1 209 Ñ 带颚化符的N Ò 00D2 210 Ò 带抑音符的O Ó 00D3 211 Ó 带锐音符的O Ô 00D4 212 Ô 带扬抑符的O Õ 00D5 213 Õ 带颚化符的O Ö 00D6 214 Ö 带分音符的O × 00D7 215 × 乘号 Ø 00D8 216 Ø 带斜线的O Ù 00D9 217 Ù 带抑音符的U Ú 00DA 218 Ú 带锐音符的U Û 00DB 219 Û 带扬抑符的U Ü 00DC 220 Ü 带分音符的U Ý 00DD 221 Ý 带锐音符的Y Þ 00DE 222 Þ 清音p ß 00DF 223 ß 清音s à 00E0 224 à 带抑音符的a á 00E1 225 á 带锐音符的a â 00E2 226 â 带扬抑符的a ã 00E3 227 ã 带颚化符的a ä 00E4 228 ä 带分音符的a å 00E5 229 å 带分音符的a æ 00E6 230 æ 小写连字AE ç 00E7 231 ç 带下加符的c è 00E8 232 è 带抑音符的e é 00E9 233 é 带锐音符的e ê 00EA 234 ê 带扬抑符的e ë 00EB 235 ë 带分音符的e ì 00EC 236 ì 带抑音符的i í 00ED 237 í 带锐音符的i î 00EE 238 î 带扬抑符的i ï 00EF 239 ï 带分音符的i ð 00F0 240 ð 带斜线的d ñ 00F1 241 ñ 带颚化符的n ò 00F2 242 ò 带抑音符的o ó 00F3 243 ó 带锐音符的o ô 00F4 244 ô 带扬抑符的o õ 00F5 245 õ 带颚化符的o ö 00F6 246 ö 带分音符的o ÷ 00F7 247 ÷ 除号 ø 00F8 248 ø 带斜线的o ù 00F9 249 ù 带抑音符的u ú 00FA 250 ú 带锐音符的u û 00FB 251 û 带扬抑符的u ü 00FC 252 ü 带分音符的u ý 00FD 253 ý 带锐音符的y þ 00FE 254 þ 小写字母Thorn ÿ 00FF 255 ÿ 带分音符的y]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android TextView Autosizing 字号自动调整大小，字号自适应]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-TextView-Autosizing-%E5%AD%97%E5%8F%B7%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%AD%97%E5%8F%B7%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[什么是Autosizeng呢，简单说就是TextView文本内容的字号大小是会根据内容多少而变大或者变小以适应布局，尽可能让TextView显示所有的文本内容。 比如TextView控件的宽高是固定的，在内容越少的情况下，为了内容填充整个控件，字号就会变大，在内容越多的情况下，为了显示更多的内容，字号就会缩小。如下图所示: 在Android 8.0（API级别26）及更高版本中，可以直接使用Autosizeng，如果想在低版本中使用，可以使用Support V4包中的TextViewCompat，可以向下兼容到Android 4.0（API级别14） 实现Autosizing功能可以在代码中设置也可以在XML中设置属性。 有三种方法可以设置Autosizing 默认设置 设置变化范围及粒度 预设可选值我们下面分别详细介绍 如果要达到Autosizing的效果，建议不要为layout_width和layout_height属性设置wrap_content的值，而是要设置一个固定的值，否则可能达不到你要的效果 使用默认设置默认设置我们不用设置Autosizing TextView字号的最小值和最大值，默认minTextSize = 12sp， maxTextSize = 112sp以及 granularity = 1px，granularity表示粒度，就是每次递增或减小的大小。 12345678910111213141516// 开启AutosizingmTextView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM);// 关闭AutosizingmTextView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_NONE);&lt;!--开启Autosizing--&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; /&gt;&lt;!--关闭Autosizing--&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;none&quot; /&gt; 以上只实适用Android 8.0及以上版本中，如果要兼容低版本，需使用Support包，如下所示： 12345678910111213141516// 开启AutosizingTextViewCompat.setAutoSizeTextTypeWithDefaults(mTextView, TextViewCompat.AUTO_SIZE_TEXT_TYPE_UNIFORM);// 关闭AutosizingTextViewCompat.setAutoSizeTextTypeWithDefaults(mTextView, TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE);&lt;!--开启Autosizing--&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:autoSizeTextType=&quot;uniform&quot; /&gt;&lt;!--关闭Autosizing--&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:autoSizeTextType=&quot;none&quot; /&gt; 设置变化范围及粒度默认值可能不满足我们的要求，那我们可以自定义变化的区间，设置一个最大值和最小值，还有变化的粒度。 在Android 8.0及更高版本中使用如下 123456789101112// 在代码中设置mTextView.setAutoSizeTextTypeUniformWithConfiguration(8, 22, TypedValue.COMPLEX_UNIT_SP);// 在XML中设置&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; android:autoSizeMinTextSize=&quot;12sp&quot; android:autoSizeMaxTextSize=&quot;100sp&quot; android:autoSizeStepGranularity=&quot;2sp&quot; /&gt; support包的使用如下 123456789101112131415161718// 在代码中设置TextViewCompat.setAutoSizeTextTypeWithDefaults(mTextView, TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE);// 在XML中设置&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:autoSizeTextType=&quot;uniform&quot; app:autoSizeMinTextSize=&quot;12sp&quot; app:autoSizeMaxTextSize=&quot;100sp&quot; app:autoSizeStepGranularity=&quot;2sp&quot; /&gt;&lt;/LinearLayout&gt; 预设可选值你也可以指定一些字号，Autosizing缩放时只会在这几种字号里变化。 在Android 8.0及更高版本中使用如下 1234567891011121314151617181920// 在代码中设置mTextView.setAutoSizeTextTypeUniformWithPresetSizes(new int[]&#123;8, 10, 16, 25&#125;, TypedValue.COMPLEX_UNIT_SP);// 在XML中设置&lt;resources&gt; &lt;array name=&quot;autosize_text_sizes&quot;&gt; &lt;item&gt;10sp&lt;/item&gt; &lt;item&gt;12sp&lt;/item&gt; &lt;item&gt;20sp&lt;/item&gt; &lt;item&gt;40sp&lt;/item&gt; &lt;item&gt;100sp&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; android:autoSizePresetSizes=&quot;@array/autosize_text_sizes&quot; /&gt; support包设置预设可选值 123456789101112131415161718192021222324252627// 在代码中设置TextViewCompat.setAutoSizeTextTypeUniformWithPresetSizes(mTextView, new int[]&#123;8, 10, 16, 25&#125;, TypedValue.COMPLEX_UNIT_SP);// 在XML中设置&lt;resources&gt; &lt;array name=&quot;autosize_text_sizes&quot;&gt; &lt;item&gt;10sp&lt;/item&gt; &lt;item&gt;12sp&lt;/item&gt; &lt;item&gt;20sp&lt;/item&gt; &lt;item&gt;40sp&lt;/item&gt; &lt;item&gt;100sp&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:autoSizeTextType=&quot;uniform&quot; app:autoSizePresetSizes=&quot;@array/autosize_text_sizes&quot; /&gt;&lt;/LinearLayout&gt; 参考 Autosizing TextViews Android官网教程 文字太多？控件太小？试试 TextView 的新特性 Autosizeing 吧！ 如果喜欢我的文章可以关注下我的公号，里面有很多干货哦]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android预定义样式?android:attr/attribute、?attr/attribute和?attribute]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F-android-attr-attribute%E3%80%81-attr-attribute%E5%92%8C-attribute%2F</url>
    <content type="text"><![CDATA[系统内建属性比如系统有一个内建属性selectableItemBackground，可以为可点击控件设置点击时的水波纹效果，以下几种方法都可以成功引用 1234567891011121314151617181920212223// 未设置前&lt;Button /&gt; // 设置水波纹点击效果&lt;Button 、、、 android:foreground=&quot;?android:attr/selectableItemBackground&quot;/&gt; // 省略attr/&lt;Button 、、、 android:foreground=&quot;?android:selectableItemBackground&quot;/&gt; // 省略android:&lt;Button 、、、 android:foreground=&quot;?attr/selectableItemBackground&quot;/&gt; // 省略android:attr/&lt;Button 、、、 android:foreground=&quot;?selectableItemBackground&quot;/&gt; 自定义属性我们先在attrs.xml文件中自定义一个属性 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; // 通过format可以设置各种不同的类型，包括style，这里不再赘述 &lt;attr name=&quot;myTextColor&quot; format=&quot;color&quot;/&gt;&lt;/resources&gt; 此时如果直接引用是没有效果的，而且会报错 123&lt;Button 、、、 android:textColor=&quot;?attr/myTextColor&quot; 我们还需要在styles.xml文件中为这个自定义属性设置一个默认值，然后再引用就可以成功了，这里我们把Button的文字设置成红色 12345&lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;myTextColor&quot;&gt;#ff0000&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 当然，和内建属性的引用一样，我们也可以省略掉attr/ 1234// 省略掉attr/也是可以引用成功的&lt;Button 、、、 android:textColor=&quot;?myTextColor&quot; 总结 Android内建属性引用前面可以加android:，但也可以省略，自定义属性则不可以加 属性的引用最短可以简化成?attribute，建议该写法比较简短 属性引用引用的其实不是引用属性，而是引用该属性设置的默认值，所以自定义属性记得在主题中设置引用属性的默认值，当人也可以再主题中更改系统内建属性的默认值 更换主题参考 Android Theme主题样式一键换肤 Android应用动态修改主题 有一个想法，可以通过在不同的主题中定义同一个自定义属性的不同默认值，然后通过setTheme();方法来切换主题，马上验证下 首先在attrs.xml文件中自定义一个属性 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; // 通过format可以设置各种不同的类型，包括style，这里不再赘述 &lt;attr name=&quot;myTextColor&quot; format=&quot;color&quot;/&gt;&lt;/resources&gt; 然后在styles.xml中定义两个不同的theme 1234567&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;myTextColor&quot;&gt;#ff0000&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;AppThemeGreen&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;myTextColor&quot;&gt;#00ff00&lt;/item&gt;&lt;/style&gt; 本来想通过Application.setTheme();方法来设置主题，但发现未生效，具体原因还未去深究，现在只能通过调用Activity.setTheme();方法来设置出题，且必须在setContentView();方法前调用，否则无法生效，可以将Activity.setTheme();调用写在基类BaseActivity的onCreate方法里。 123456789101112public class MainActivity extends Activity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // setTheme(R.style.AppTheme); // 可以有一个换肤的页面供选择，然后把选择的选择的theme保存到Sharepreference中 setTheme(R.style.AppThemeGreen); setContentView(R.layout.activity_main);&#125; 总结： Application.setTheme()设置主题无法生效 Activity.setTheme()设置主题需在setContentView之前调用才能生效 缺点：1.假设有个换肤选择的Activity页面，选择后无法实时生效，需重启Activity。就是说已打开的Activity是无法马上看到效果的，新打开的Activity才能够看到换肤效果。2.该换肤实现方式的所有主题需写死在styles.xml文件内，无法实现后台下载新皮肤。至于下载新皮肤网上有通过apk文件的方式，以后可以深入研究下。 参考 @android, ?attr/ 和 ?android 的区别 Android中 @和?区别以及?attr/与@style/等的区别 如果喜欢我的文章，可以扫描以下二维码关注我的微信公众号，我会定期发布最新的文章。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ViewPager通过PageTransformer实现切换时背景色的渐变]]></title>
    <url>%2F2019%2F07%2F06%2FViewPager%E9%80%9A%E8%BF%87PageTransformer%E5%AE%9E%E7%8E%B0%E5%88%87%E6%8D%A2%E6%97%B6%E8%83%8C%E6%99%AF%E8%89%B2%E7%9A%84%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[定个小目标我们要实现如下的效果，ViewPager正中的page显示为绿色，其余两边的显示为蓝色。中间page向左右两边切换时会从绿色慢慢过渡到蓝色，同理两边的page向中间切换时颜色也会慢慢过渡，而不是直接跳变。 PageTransformer为了实现以上效果我们要借助PagerTransfromer，所以有必要简单介绍下 1234567891011121314151617181920/** * A PageTransformer is invoked whenever a visible/attached page is scrolled. * This offers an opportunity for the application to apply a custom transformation * to the page views using animation properties. * * &lt;p&gt;As property animation is only supported as of Android 3.0 and forward, * setting a PageTransformer on a ViewPager on earlier platform versions will * be ignored.&lt;/p&gt; */public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ void transformPage(View page, float position);&#125; PageTransformer很简单，就只有一个transformPage方法。第一个参数是我们要变换颜色的page。 重点看第二个参数，英语好的话直接看注释说得很明白，意思就是我们当前要变化的页面当前位置的中心距离pager中心的距离，比如当前处于中心的page的position就是0，右边第一个page的position=1，右边第二个page的position为2，左边第一个page的position=-1，左边第二个page的position=-2，以此类推。 当然position的值不可能一直是整数，比如当处于中间位置的page向右边切换到右边第一个位置时，position的值会从0变化到1，1就是表示一个page的宽度，从中间位置移到右边第一个位置就是移动了一个page的宽度。如果向右移动到一半，那么position就是0.5。 实现的思路只有中间位置是绿色，其余两边的都是蓝色，所以可以确定的是position=0，肯定是绿色，position的绝对值Math.abs(position)&gt;=1一定是蓝色，剩下的我们就是要处理-1&lt;position&lt;1这些位置的渐变色，也就是中间位置到左右两边第一个page的位置。 中间位置到左右两边第一个page的位置的position取绝对值的值范围从0-1，其实就是0%-100%，我们可以用这个值当做颜色的变化率，0就是绿色，值越大表示越往蓝色变化，1就表示变成蓝色了。 另一个难点就是如何实现颜色的渐变。我们知道颜色由RGB表示，有三个颜色的分量分别表示红绿蓝。我们把起始颜色和最终颜色的三个颜色分量分别取出来，分别计算三个颜色分量的差值，最后用差值乘以变化率再加上初始颜色分量就是当前的颜色分量值，把三个当前颜色分量的值拼起来就是当前的颜色值。 初始颜色：#00ff00最终颜色：#0000ff初始颜色分量：红00，绿ff(255)，蓝00最终颜色分量：红00，绿00，蓝ff(255)颜色分量差值：红00，绿-255，蓝255 假设我们要计算position=0.5位置的颜色当前红色分量=0+0.500=0=0x00当前绿色分量=255+0.5(-255)=127=0x7f当前蓝色分量=0+0.5*255=127=0x7f 所以position=0.5时当前的颜色为#007f7f。 代码实现一个很简单的功能说了这么多，就是为了让大家更好的理解，如果直接放代码看了坑能会一头雾水 设置PagerTransfromer 12345678910111213mViewPager.setPageTransformer(true, new ViewPager.PageTransformer() &#123; @Override public void transformPage(@NonNull View view, float v) &#123; // 取绝对值 v = Math.abs(v); // 超过左右两边第一个位置的page都设置成蓝色 if (v &gt; 1) &#123; v = 1; &#125; String color = transColor(&quot;#00ff00&quot;, &quot;#0000ff&quot;, v); view.setBackgroundColor(Color.parseColor(color)); &#125;&#125;); 计算当前颜色值 1234567891011121314151617181920212223242526272829303132333435/** * 根据起始颜色、最终颜色和变化率计算当前颜色 * @param start 起始颜色 * @param end 最终颜色 * @param rate 变化率 * @return 当前颜色 */private static String transColor(String start, String end, float rate) &#123; // 获取初始颜色的RGB分量 String startR = start.substring(1, 3); String startG = start.substring(3, 5); String startB = start.substring(5, 7); // 获取最终颜色的颜色分量 String endR = end.substring(1, 3); String endG = end.substring(3, 5); String endB = end.substring(5, 7); // 计算初始颜色的RGB分量十进制值 int startRI = Integer.parseInt(startR, 16); int startGI = Integer.parseInt(startG, 16); int startBI = Integer.parseInt(startB, 16); // 计算最终颜色的RGB分量十进制值 int endRI = Integer.parseInt(endR, 16); int endGI = Integer.parseInt(endG, 16); int endBI = Integer.parseInt(endB, 16); // 计算当前颜色分量 int curRI = (int) (startRI + (endRI - startRI)*rate); int curGI = (int) (startGI + (endGI - startGI)*rate); int curBI = (int) (startBI + (endBI - startBI)*rate); // 转成16进制 String curR = String.format(&quot;%02x&quot;, curRI); String curG = String.format(&quot;%02x&quot;, curGI); String curB = String.format(&quot;%02x&quot;, curBI); // 拼成颜色码 return &quot;#&quot; + curR + curG + curB;&#125; 如果喜欢我的文章，可以扫描以下二维码关注我的微信公众号，我会定期发布最新的文章。关注我的微信，回复背景色渐变获取本文的完整代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Base64加密解密]]></title>
    <url>%2F2019%2F07%2F06%2FBase64%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[参考Java8 Base64BASE64在线加密解密 Android自带Base64加密1234import android.util.Base64;String encode2 = new String(Base64.encode("123456".getBytes(), Base64.DEFAULT)); // 结果为"MTIzNDU2\n"// encodeToString内部其实也是调用encode方法，若想直接返回String，推荐用该方法String encode1 = Base64.encodeToString("123456".getBytes(), Base64.DEFAULT); // 结果为"MTIzNDU2\n" 这里要注意以上方法最终返回的结果都有换行符\n，如果不要换行可以用trim()做以下处理 123import android.util.Base64;String encode2 = new String(Base64.encode("123456".getBytes(), Base64.DEFAULT)).trim(); // 结果为"MTIzNDU2"String encode1 = Base64.encodeToString("123456".getBytes(), Base64.DEFAULT).trim(); // 结果为"MTIzNDU2" Android自带Base64解密1234import android.util.Base64;String decode1 = new String(Base64.decode("MTIzNDU2".getBytes(), Base64.DEFAULT)); // 结果为"123456"// 该方式内部其实也是调用上面那个方法，省去了getBytes()，推荐用此方法String decode2 = new String(Base64.decode("MTIzNDU2", Base64.DEFAULT)); // 结果为"123456" Java自带Base64加密解密参考Java8 Base64以上例子用的是Android自带的android.util.Base64类 其实Java也有个java.util.Base64，但是这个类需在Android API 26及以上才可以使用 12345String encode1 = new String(Base64.getEncoder().encode("123456".getBytes())); // 结果为"MTIzNDU2"String encode2 = Base64.getEncoder().encodeToString("123456".getBytes()); // 结果为"MTIzNDU2"String decode1 = new String(Base64.getDecoder().decode("MTIzNDU2".getBytes())); // 结果为"123456"String decode2 = new String(Base64.getDecoder().decode("MTIzNDU2")); // 结果为"123456" 可以看到编码的结果不像Android自带的末尾还有换行符\n 关于Java的Base64还有以下方法 Base64.getUrlEncoder(); Base64.getMimeEncoder(); Base64.getUrlDecoder(); Base64.getMimeDecoder(); 这里不再展开，以后另开一篇文章介绍如果你喜欢我的文章，可以关注我的微信公众号，可以看到我最新发布的文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 虚拟环境 virtualenv]]></title>
    <url>%2F2019%2F07%2F06%2FPython-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-virtualenv%2F</url>
    <content type="text"><![CDATA[virtualenv安装1pip install virtualenv 创建虚拟环境123C:\Users\Him&gt;d: // 切换到D:盘D:\&gt;cd D:\Python\env // 进入到要创建虚拟环境的目录下D:\Python\env&gt;virtualenv myenv // 创建成功后在D:\Python\env目录下会多一个myenv目录 也可以在创建时指定python版本 1virtualenv -p D:\Program\Python27\python.exe myenv27 进入虚拟环境123D:\Python\env&gt;cd myenv\Scripts // 进入虚拟环境的Scripts目录下D:\Python\env\myenv\Scripts&gt;activate // 运行activate(myenv) D:\Python\env\myenv\Scripts&gt; // 激活成功，注意命令行前多了(myenv) 查看虚拟环境下安装的库123456(myenv) D:\Python\env\myenv\Scripts&gt;pip listPackage Version---------- -------pip 18.0setuptools 40.0.0wheel 0.31.1 在虚拟环境下安装库1(myenv) d:\Python\env\myenv\Scripts&gt;pip install request 退出虚拟环境12(myenv) D:\Python\env\myenv\Scripts&gt;deactivateD:\Python\env\myenv\Scripts&gt; // 注意命令行前的(myenv)没了 requirements文件将当前环境的包写入requirements文件文件，以及根据requirements文件文件安装包。 生成requirements文件文件：pip freeze &gt;requirements.txt 根据requirements文件安装包：pip install -r requirements.txt requirements.txt文件的格式如下： 12345678910111213141516Flask==0.11.1Flask-Bootstrap==3.3.6.0Flask-Login==0.3.2Flask-Migrate==1.8.1Flask-Moment==0.5.1Flask-PageDown==0.2.1Flask-Script==2.0.5Flask-SQLAlchemy==2.1Flask-WTF==0.12html5lib==0.9999999itsdangerous==0.24Jinja2==2.8Mako==1.0.4Markdown==2.6.6MarkupSafe==0.23PyMySQL==0.7.5]]></content>
  </entry>
  <entry>
    <title><![CDATA[python itertools]]></title>
    <url>%2F2019%2F07%2F06%2Fpython-itertools%2F</url>
    <content type="text"><![CDATA[islice切片 123456789101112131415161718192021222324252627&gt;&gt;&gt; def count(n):... while True:... yield n... n += 1...&gt;&gt;&gt; c = count(0)&gt;&gt;&gt; c[10:20]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;generator&apos; object is not subscriptable&gt;&gt;&gt; # Now using islice()&gt;&gt;&gt; import itertools&gt;&gt;&gt; for x in itertools.islice(c, 10, 20):... print(x)...10111213141516171819&gt;&gt;&gt; 123456789101112131415In [97]: ls = [0,1,2,3,4,5,6,7,8,9]In [98]: for i in itertools.islice(ls, None, 3): # 等价于ls[:3] ...: print(i)012In [99]: for i in itertools.islice(ls, 4, None): # 类似于ls[4:] ...: print(i)456789 dropwhile抛弃符合函数的值，但是实际测试跟我所理解的有所出入 如下代码本来期望去掉b开头的，结果却全部输出了 12345678In [105]: for i in itertools.dropwhile(lambda item : item.startswith(&apos;b&apos;), ls): ...: print(i)a1b1a2b2a3b3 再试，去掉小于4的怪哉了，换成数字却又可以了 1234567In [106]: ls = [1,2,3,4,5,6,7,8]In [107]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)5678 再试，条件一样还是去掉大于5的，改变列表值这次又不是我所期望的但是好像有点眉目了，第一个item不满足条件就直接输出全部了我们是不是可以假设该函数抛弃前面满足条件的值，直到出现不满足的值后就不再判断，即使在这个值后可能还会出现满足条件的值也不再抛弃 1234567891011In [108]: ls = [6,3,8,9,1,5,4,2]In [109]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)63891542 二话不说，赶紧验证一下 1234567891011In [110]: ls = [1,2,3,4,6,3,8,9,1,5,4,2]In [111]: for i in itertools.dropwhile(lambda item : item &lt; 5, ls): ...: print(i)63891542 果然如此 permutations排列（与顺序有关） 123456789101112131415161718In [112]: items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]In [113]: for i in itertools.permutations(items): # 默认排列的长度为items的长度 ...: print(i)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;c&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;c&apos;, &apos;a&apos;)(&apos;c&apos;, &apos;a&apos;, &apos;b&apos;)(&apos;c&apos;, &apos;b&apos;, &apos;a&apos;)In [114]: for i in itertools.permutations(items, 2): # 指定排列的长度 ...: print(i)(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;a&apos;)(&apos;b&apos;, &apos;c&apos;)(&apos;c&apos;, &apos;a&apos;)(&apos;c&apos;, &apos;b&apos;) combinations组合（与顺序无关） 1234567891011121314151617In [112]: items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]In [116]: for i in itertools.combinations(items, 3): ...: print(i)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)In [117]: for i in itertools.combinations(items, 2): ...: print(i)(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;c&apos;)(&apos;b&apos;, &apos;c&apos;)In [118]: for i in itertools.combinations(items, 1): ...: print(i)(&apos;a&apos;,)(&apos;b&apos;,)(&apos;c&apos;,) combinations_with_replacement元素可重复出现的组合 123456In [119]: items = [&apos;a&apos;, &apos;b&apos;]In [120]: for i in itertools.combinations_with_replacement(items, 2): ...: print(i)(&apos;a&apos;, &apos;a&apos;)(&apos;a&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;b&apos;) zip_longest功能与内置函数zip类似，只是输出以最长的序列为准 12345678910111213141516171819202122In [45]: import itertoolsIn [26]: als = [1,2,3,4,5,6]In [27]: bls = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]In [46]: for a,b in itertools.zip_longest(als,bls): # 输出以最长的序列为准，不足的为None ...: print(a,b)1 a2 b3 c4 d5 None6 None# None替换成fillvalue的值In [48]: for a,b in itertools.zip_longest(als,bls,fillvalue=&apos;letter&apos;): ...: print(a,b)1 a2 b3 c4 d5 letter6 letter chain123456789101112131415161718In [49]: import itertoolsIn [50]: als = [1,2,3,4]In [51]: bls = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)# 注意两种不同类型的可迭代随想也可以完美输出In [52]: for item in itertools.chain(als,bls): ...: print(item)1234abcd# 类型In [53]: type(itertools.chain(als,bls))Out[53]: itertools.chain]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android js和原生交互]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-js%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[简单的demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.xindeco.swingu_h5;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.webkit.JavascriptInterface;import android.webkit.ValueCallback;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.EditText;import android.widget.Toast;import com.xindeco.reader.common.Action;import com.xindeco.reader.common.ReaderListener;import com.xindeco.reader.common.Tag;import com.xindeco.reader.swingu.SwingUReader;public class MainActivity extends AppCompatActivity &#123; private WebView mWebView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); &#125; private void init() &#123; mWebView = findViewById(R.id.web_view); mWebView.loadUrl(&quot;file:///android_asset/test.html&quot;); WebSettings webSettings = mWebView.getSettings(); webSettings.setJavaScriptEnabled(true); mWebView.addJavascriptInterface(new JsInteration(), &quot;android&quot;); mWebView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (url.equals(&quot;https://www.baidu.com/&quot;)) &#123; Toast.makeText(MainActivity.this, &quot;就是要拦你&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; else &#123; mWebView.loadUrl(url); return true; &#125; &#125; &#125;); findViewById(R.id.call_js).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; final EditText input = findViewById(R.id.input); String content = input.getText().toString().trim(); if (!TextUtils.isEmpty(content)) &#123; // 调用js方法，更新页面// mWebView.loadUrl(&quot;javascript:change(\&quot;&quot; + content + &quot;\&quot;)&quot;); // 没带返回值的调用方式 mWebView.evaluateJavascript(&quot;javascript:change(\&quot;&quot; + content + &quot;\&quot;)&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; input.setText(value); &#125; &#125;); &#125; &#125; &#125;); &#125; public class JsInteration &#123; @JavascriptInterface public String toast(String msg) &#123; Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show(); return &quot;我是java的返回值&quot;; &#125; &#125;&#125; 布局 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/input&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;我要改变网页的内容&quot;/&gt; &lt;Button android:id=&quot;@+id/call_js&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我是原生的button啦&quot;/&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; HTML页面，把该页面放置在assets文件夹下 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;content-type&quot;&gt; &lt;title&gt;js和原生交互&lt;/title&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;!--该方法调用原生的toast方法--&gt; function toast()&#123; var s = document.getElementById(&quot;input_toast&quot;).value; var result = window.android.toast(s); document.getElementById(&quot;input_toast&quot;).value=result; &#125; &lt;!--该方法被原生调用--&gt; function change(content)&#123; document.getElementById(&quot;input_toast&quot;).value=content; return &quot;我是js的返回值&quot;; &#125; &lt;/script&gt; &lt;body&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;input_toast&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;toast&quot; value=&quot;toast&quot; onclick=&quot;toast()&quot;/&gt; &lt;/p&gt; &lt;a href=&quot;https://www.taobao.com/&quot;&gt;跳转淘宝，不拦你&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;https://www.baidu.com/&quot;&gt;跳转百度，别拦我&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 记得添加&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;权限才能访问网络]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android自定义标题栏]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[void onCreate(Bundle savedInstanceState) &#123;123456public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_CUSTOM_TITLE); // 必须设置在setContentView之前。 setContentView(R.layout.activity_main); getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.custom_title);//custom_title为自定义标题栏布局&#125; 修改AndroidManifest.xml中该Activity的theme为以下： 其中parent要设为android:Theme或android:Theme.Light，不能设为android:Theme.Holo.Light，否则会报You cannot combine custom titles with other title features错误，可能是因为android:Theme.Holo.Light是用于ActionBar的，跟自定义标题栏有冲突。 50dp//改为跟自定义标题栏的高度一样 @color/title_bg//改为跟自定义标题栏的背景一样]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 的文件存储]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid-%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[选择内存储还是外存储 所有安卓设备都有两个存储区域，内存储和外存储。以前的安卓设备都有提供一个内置的存储（内存储），和一个可插拔的存储（外存储），例如SD卡。但是现在的许多设备是不支持外置存储卡的，而是把内置的存储分成两个区域，相当于内存储和存储。所以不管设备是否支持外置存储卡，它都有内存储和外存储这两个区域。存储操作相关API的调用是一样的。以下是内存储和外存储的区别： 内存储： 一直可用 默认情况下，存储于此的文件只有该应用本身有权限操作。 当用户卸载该应用，系统会删除该应用存储在内存储的所有文件。 如果你不想用户和其他应用操作你的文件，最好的方式就是保存在内存储。 外存储： 并非一直可用，比如当用户用数据线连接电脑并打开数据存储或者移除存储卡。 对用户和其他应用可读。 当用户卸载该应用时必不会删除存储在外存储的文件，除非你保存的时候调用的是getExternalFilesDir(). 如果你要保存的文件对操作权限没有要求，比如和其他应用共享或者允许用户操作，那么最好的方式就是存储在外存储。 Tip:** 默认情况下应用是安装在内存储，但是你可以在manifest中指定android:installLocation的属性值让应用安装在外存储上。特别是当应用应用特别大，而用户又有足够的问存储空间时。更多详情，请查阅App Install Location。 获得外存储权限 要在外存储上执行写的操作，必须在manifest文件中请求WRITE_EXTERNAL_STORAGE权限： 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; Caution:目前，所有应用不必声明相关权限就可以在外存储上执行读的操作。然而，不久的将来就需要了。如果你的应用需要读取的操作（不需要写的操作），你可以在manifest中声明READ_EXTERNAL_STORAGE权限，这样可以保证应用在后续版本中正常运行（即使当前系统并不要求该权限）。 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; 如果你的应用已经声明了WRITE_EXTERNAL_STORAGE权限，就没必要再声明READ_EXTERNAL_STORAGE权限，因为WRITE_EXTERNAL_STORAGE默认包含了写的权限。 You don’t need any permissions to save files on the internal storage. Your application always has permission to read and write files in its internal storage directory.对于内存储并不需要任何读写的权限。 在内存储中保存文件 当要在内存储存储文件时，可以通过以下两种方式获取合适的存储位置： getFilesDir() 返回一个分配给该应用的内存储文件夹。 getCacheDir() 返回一个分配给该应用的内存储缓存文件夹File对象。当缓存文件不再需要时记得删除掉。当系统存储不够用时，系统可能会删除掉缓存的文件且没有提示。 要在以上任一种文件夹中创建文件时，可以用File(dir, fileName)构造方法，第一个参数传入以上其中一种方法返回的内存储文件夹对象： 1File file = new File(context.getFilesDir(), filename); 还有另一种方法，你可以调用[openFileOutput()](http://developer.android.com/reference/android/content/Context.html#openFileOutput(java.lang.String, int))来打开一个连接内存储文件的FileOutputStream 对象。如下所示如何在内存储文件中写入内容： 1234567891011String filename = &quot;myfile&quot;;String string = &quot;Hello world!&quot;;FileOutputStream outputStream;try &#123; outputStream = openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(string.getBytes()); outputStream.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 或者说，你需要缓存文件，你可以使用[createTempFile()](http://developer.android.com/reference/java/io/File.html#createTempFile(java.lang.String, java.lang.String))。例如以下的示例从一个URL中提取出文件名，再用这个文件名创建一个存储在缓存文件夹中的文件： 12345678910public File getTempFile(Context context, String url) &#123; File file; try &#123; String fileName = Uri.parse(url).getLastPathSegment(); file = File.createTempFile(fileName, null, context.getCacheDir()); catch (IOException e) &#123; // Error while creating file &#125; return file;&#125; Note:一个应用的内存储空间是由应用包名标示的在安卓文件系统中的一个特定区域，技术上来讲，如果把文件的mode设为可读，那么其他应用就可访问。但是，前提是其他应用必须预先知道你的应用的包名和要访问的文件名。除非你明确声明某个文件为可读或可写，否则其他应用无法访问你的内存储文件也没有读写的权限。 在外存储中保存文件 因为外存储有可能是不可用的，比如当用户打开USB数据存储或者是卸载提供外存储的SD卡时，所以每当你要使用外存储是最好先核实下外存储是否可用。你可以通过调用getExternalStorageState()来查询外存储的状态。如果返回的状态是MEDIA_MOUNTED，那么表示你可以读写外存储。例如，以下两个非常实用的方法可以用来确定外存储的可用性： 123456789101112131415161718/* Checks if external storage is available for read and write确定问存储是否可读写 */public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;/* Checks if external storage is available to at least read 确定外存储是都至少可读*/public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; 虽然说整个外存储对于用户和所有应用都是可操作的，但是有两种类型的文件你可能会存储在这里： 公开文件 对其他应用和用户开放的文件应该存储在这里，当用户卸载你的应用时，这些文件应该保留。比如你的应用拍摄的图片或下载的文件。 私有文件 完全属于你的应用的文件并且在用户卸载你的应用时应该被删除的文件可以存储在这里。虽然技术上来说，存储在外存储的文件对于用户和其他应用都可以访问，但是这些文件对于用户和其他应用一文不值。当用户删除你的应用时，系统会自动删除你的应用存储在这里的所有文件。比如说你的应用下载的资源文件或临时的文件。 如果你想在外存储中保存公共文件，可以用getExternalStoragePublicDirectory()方法来获取一个在外存储中的File文件夹对象。这个方法的第一个参数用来指定要保存的文件的类型，可以被系统分类，例如DIRECTORY_MUSIC或者DIRECTORY_PICTURES。如下所示： 123456789public File getAlbumStorageDir(String albumName) &#123; // Get the directory for the user&apos;s public pictures directory. File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 如果你想保存应用私有的文件，可以调用getExternalFilesDir()来获取相应的文件夹，并在第一个参数指定你想要的类型。每个用这个方式创建的文件夹都是放在一个父文件夹里，这个父文件夹存里放着所有当用户卸载该应用时系统会自动删除的文件。 例如，以下的方法用来创建一个存放照片的文件夹： 123456789public File getAlbumStorageDir(Context context, String albumName) &#123; // Get the directory for the app&apos;s private pictures directory. File file = new File(context.getExternalFilesDir( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 如果没有一个系统预定义的类型子文件夹的名字适合你要保存的文件，你也可以在调用getExternalFilesDir()方法时第一个参数传null，这样返回的是在外存储中分配给你的应用的私有文件夹根目录。 要记住，存储在由getExternalFilesDir()返回的文件夹中的文件，当用户卸载你的应用时，这些文件全部会被删除。如果你想要用户删除你的应用后还保留这些文件，最好是使用getExternalStoragePublicDirectory()方法。比如说你的应用是个相机应用，当卸载该应用时用户还想保留所拍的照片。 不管你是用getExternalStoragePublicDirectory()来存储共享的文件，还是用getExternalFilesDir()来存储私有文件，最好是使用API常量定义的文件夹名，比如DIRECTORY_PICTURES。使用这些文件夹名可以确保系统正确分类这些文件。例如，保存在DIRECTORY_RINGTONES中的文件会被系统media scanner归类为铃音而非音乐。 查询剩余存储空间 如果你在保存某一文件时事先知道该文件的大小，你可以通过调用getFreeSpace() 或者 getTotalSpace()来确定是否有足够的存储空间来保存该文件以免造成IOException异常。 但是，系统并不保证你通过getFreeSpace()查询出来有多少剩余存储就可以存储多少。如果剩余存储容量比你要存储的文件大小大个几MB，那么一般可以成功存储。 Note:其实你也可以不用在存储文件前预先查询剩余多少存储空间，你可以尝试着直接写入数据，然后如果有出现异常直接捕获就行了。这种写法一般可以用在当你事先不知道要写入数据的大小的时候。比如说当你要保存一张PNG格式的图片前要先把他转化为JPEG格式，那么你就不知道要保存的数据的大小。 删除文件 你应该经常删除不再需要的文件，最直接的方法就是直接调用File对象的delete()方法。 1myFile.delete(); 如果要删除的文件是存储在内存储中，你可以通过调用Conext的deleteFile()方法来删除。 1myContext.deleteFile(fileName); Note:当用户卸载你的应用时，安卓系统会自动删除以下位置的文件： 存储在内存储中的所有文件 通过getExternalFilesDir()方法存储在外存储中的所有文件。 然而你应该制定一个规则定期删除内存储缓存文件夹中的缓存文件和其他你不再需要的文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Failed to fetch URL https://dl-ssl.google.com/android/repository/addons_list-1.xml]]></title>
    <url>%2F2019%2F07%2F06%2FFailed-to-fetch-URL-https-dl-ssl-google-com-android-repository-addons-list-1-xml%2F</url>
    <content type="text"><![CDATA[Do the following: Close the sdk manager and eclipse. Go to the folder where you have stored your adt. In that adt folder you’ll find a folder known as tools. Make a copy of the contents of that folder and paste it in a folder called copytools. Now go to the command prompt and go to the location of the copytools. Then execute the command android.bat the sdk manager will start. Now update all the plugins you want. It’ll update your original folder. After the update delete the copy.]]></content>
  </entry>
  <entry>
    <title><![CDATA[java进制转换]]></title>
    <url>%2F2019%2F07%2F06%2Fjava%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728int n1 = 14;//十进制转成十六进制：Integer.toHexString(n1);//十进制转成八进制Integer.toOctalString(n1);//十进制转成二进制Integer.toBinaryString(12);//十六进制转成十进制Integer.valueOf("FFFF",16).toString();//十六进制转成二进制Integer.toBinaryString(Integer.valueOf("FFFF",16));//十六进制转成八进制Integer.toOctalString(Integer.valueOf("FFFF",16));//八进制转成十进制Integer.valueOf("576",8).toString();//八进制转成二进制Integer.toBinaryString(Integer.valueOf("23",8));//八进制转成十六进制Integer.toHexString(Integer.valueOf("23",8));//二进制转十进制Integer.valueOf("0101",2).toString();//二进制转八进制Integer.toOctalString(Integer.parseInt("0101", 2));//二进制转十六进制Integer.toHexString(Integer.parseInt("0101", 2));]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView.ItemDecoration实现StrickyHeader、粘性头部、悬停头部]]></title>
    <url>%2F2019%2F06%2F19%2FRecyclerView-ItemDecoration%E5%AE%9E%E7%8E%B0StrickyHeader%E3%80%81%E7%B2%98%E6%80%A7%E5%A4%B4%E9%83%A8%E3%80%81%E6%82%AC%E5%81%9C%E5%A4%B4%E9%83%A8%2F</url>
    <content type="text"><![CDATA[参考 RecyclerView探索之通过ItemDecoration实现StickyHeader效果这篇文章真是完美，写得非常清晰，一步步实现下来，看完真是茅塞顿开，以前一直以为这个知识点很难的。 Android 从零开始实现RecyclerView分组及粘性头部效果这篇文章貌似更牛逼，但是没深入去看 RecyclerView 悬浮/粘性头部——StickyHeaderDecoration 其实在GitHub上已经有很多开源的很成熟的StickyHeader项目 timehop/sticky-headers-recyclerview 先来实现效果镇楼 实现代码Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.him.stickyheader;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public List&lt;String&gt; datas; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView mRecyclerView = findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mRecyclerView.addItemDecoration(new MyItemDecoration(new MyItemDecoration.GroupInfoCallback() &#123; // 根据全局数据的位置position查询所属分组的信息GroupInfo @Override public GroupInfo getGroupInfo(int position) &#123; // 测试数据，暂时10条数据一组 int size = 10; GroupInfo info = new GroupInfo(); info.groupId = position / size; info.title = info.groupId + &quot;&quot;; info.position = position % size; info.groupSize = size; return info; &#125; &#125;)); initDatas(); mRecyclerView.setAdapter(new MyAdapter(datas)); &#125; // 初始化测试数据 private void initDatas() &#123; datas = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100;i++) &#123; datas.add(&quot;test &quot; + i); &#125; &#125;&#125; Adapter 1234567891011121314151617181920212223242526272829303132333435363738394041package com.him.stickyheader;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; public List&lt;String&gt; datas; public MyAdapter(List&lt;String&gt; datas) &#123; this.datas = datas; &#125; @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View itemView = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item, viewGroup, false); return new MyViewHolder(itemView); &#125; @Override public void onBindViewHolder(@NonNull MyViewHolder viewHolder, int i) &#123; viewHolder.text.setText(datas.get(i)); &#125; @Override public int getItemCount() &#123; return datas == null ? 0 :datas.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView text; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); text = itemView.findViewById(R.id.text); &#125; &#125;&#125; ItemDecoration，这是最重要的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.him.stickyheader;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Rect;import android.support.annotation.NonNull;import android.support.v7.widget.RecyclerView;import android.view.View;import java.util.function.IntBinaryOperator;public class MyItemDecoration extends RecyclerView.ItemDecoration &#123; // 普通分割线的高度 private int dividerHeight = 1; // 分组header高度 private int headerHeight = 65; // 根据position获取分组信息的回调 private GroupInfoCallback callback; // 画笔 private Paint paint; public MyItemDecoration(GroupInfoCallback callback) &#123; this.callback = callback; paint = new Paint(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int itemPosition = parent.getChildAdapterPosition(view); GroupInfo info = callback.getGroupInfo(itemPosition); if (info.isFirstItem()) &#123; // 分组第一个item撑开一个header的高度 outRect.top = headerHeight; &#125; else &#123; // 其他item撑开一个普通divider的高度 outRect.top = dividerHeight; &#125; &#125; @Override public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123; super.onDraw(c, parent, state); // header左右边的坐标，注意考虑parent的左右padding float left = parent.getPaddingLeft(); float right = parent.getWidth() - parent.getPaddingRight(); // 循环RecyclerView中当前可见的View for (int i = 0; i &lt; parent.getChildCount(); i++) &#123; View child = parent.getChildAt(i); // 根据当前view获取在整个列表中的位置 int itemPosition = parent.getChildAdapterPosition(child); // 根据position获取所属分组的信息 GroupInfo info = callback.getGroupInfo(itemPosition); // 重点来了，敲黑板 // 注意这里的i表示在RecyclerView当前可见View中的位置（第几个） // i == 0表示当前可见的第一个View // 这里绘制分组标题悬停的效果 if (i == 0) &#123; // 分组标题停在最顶部，就是parent的顶部，然后再考虑顶部的padding float top = parent.getPaddingTop(); // top加分组高度就是底部坐标 float bottom = top + headerHeight; // 这里是第二个重点 // 如果没这段代码，就无法实现下面的分组标题把当前悬停的分组标题往上推出页面的效果 // 分组的最后一个item且该item的底部坐标小于悬停顶部的header的底部坐标的情况下，需执行以下代码，重新计算header的位置 if (info.isLastItem() &amp;&amp; bottom &gt; child.getBottom()) &#123; bottom = child.getBottom(); top = bottom - headerHeight; &#125; drawHeader(left, top, right, bottom, c, info); &#125; else if (info.isFirstItem()) &#123; // 如果不是可见的第一个view但是是分组的第一个item，则绘制分组标题 // item的顶部再往上一个header的高度 float top = child.getTop() - headerHeight; // 顶部坐标加上header高度就是底部坐标 float bottom = top + headerHeight; drawHeader(left, top, right, bottom, c, info); &#125; &#125; &#125; // 根据计算出的header位置绘制header及header中的title private void drawHeader(float left, float top, float right, float bottom, Canvas c, GroupInfo info) &#123; // 设置header背景色，然后绘制 paint.setColor(Color.GREEN); c.drawRect(left, top, right, bottom, paint); // 设置title文字大小，然后计算文字高度，用于接下来计算文字绘制的位置 paint.setTextSize(32); paint.setColor(Color.BLUE); Rect rect = new Rect(); // 计算要绘制的文字的宽高 paint.getTextBounds(info.title, 0, info.title.length(), rect); int textWidth = rect.width(); int textHeight = rect.height(); // 文字距左边的距离 float textX = left + 40; // 计算baseline，中文情况下为文字的底部 float textY = top + (headerHeight + textHeight)/2; c.drawText(info.title, textX, textY, paint); &#125; // 根据所在列表的位置计算所属分组的信息 public interface GroupInfoCallback &#123; GroupInfo getGroupInfo(int position); &#125;&#125; 分组信息的Model类 12345678910111213141516171819202122package com.him.stickyheader;public class GroupInfo &#123; // 分组的id public int groupId; // 分组显示的title public String title; // 在分组中的位置 public int position; // 分组的大小 public int groupSize; // 是否是分组的第一个 public boolean isFirstItem() &#123; return position == 0; &#125; // 是否是分组的最后一个 public boolean isLastItem() &#123; return position == (groupSize - 1); &#125;&#125; Activity布局 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:background=&quot;#b5b8de&quot;&gt; &lt;!--设置和item不同的背景色，当做divider的颜色--&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; item布局 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ffffff&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 获取源代码扫描以下二维码关注我的微信公众号野猿新一，发送“悬停头部”获取源代码的下载方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
